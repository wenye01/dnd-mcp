# DND MCP Client 代码规范

本文档定义了DND MCP Client项目的编码规范和最佳实践。

## 目录

- [命名规范](#命名规范)
- [文件组织](#文件组织)
- [代码格式](#代码格式)
- [注释规范](#注释规范)
- [错误处理](#错误处理)
- [接口设计](#接口设计)
- [测试规范](#测试规范)
- [最佳实践](#最佳实践)

---

## 命名规范

### 包命名

```go
// ✅ 推荐：小写单词，简洁明了
package store
package models
package handler

// ❌ 避免：下划线、混合大小写、缩写
package store_data
package Models
package handler
```

### 文件命名

```go
// ✅ 推荐：小写加下划线
session_store.go
message_handler.go
api_server.go

// ❌ 避免：驼峰命名、连字符
sessionStore.go
message-handler.go
```

### 常量命名

```go
// ✅ 推荐：大写加下划线
const MaxRetries = 3
const DefaultTimeout = 30 * time.Second

// ❌ 避免：驼峰命名、小写
const maxRetries = 3
const defaultTimeout = 30 * time.Second
```

### 变量命名

```go
// ✅ 推荐：驼峰命名，有意义
sessionCount := 0
redisClient := redis.NewClient(...)
messageList := []string{}

// ❌ 避免：无意义缩写、下划线
sc := 0
redis_cli := redis.NewClient(...)
msg_list := []string{}
```

### 接口命名

```go
// ✅ 推荐：方法名+er，或描述性名词
type SessionStore interface {}
type MessageStore interface {}
type HealthChecker interface {}

// ❌ 避免：ISession、SessionInterface
type ISession interface {}
type SessionInterface interface {}
```

### 函数命名

```go
// ✅ 推荐：动词+名词，清晰表达意图
func CreateSession(...) *Session {}
func GetMessageByID(...) (*Message, error) {}
func IsValidSession(...) bool {}

// ❌ 避免：模糊不清
func Session(...) *Session {}
func Get(...) (*Message, error) {}
func Check(...) bool {}
```

---

## 文件组织

### 文件结构

```go
// ✅ 标准Go文件结构
package package_name

// 导入
import (
    "标准库"
    "第三方库"
    "项目内部包"
)

// 常量
const ...

// 变量
var ...

// 接口
type XxxInterface interface {...}

// 类型
type XxxType struct {...}

// 构造函数
func NewXxx() *XxxType {...}

// 公共方法
func (x *XxxType) PublicMethod() {...}

// 私有方法
func (x *XxxType) privateMethod() {...}
```

### 导入顺序

```go
import (
    // 1. 标准库
    "context"
    "time"

    // 2. 第三方库
    "github.com/gin-gonic/gin"
    "github.com/redis/go-redis/v9"

    // 3. 项目内部包
    "github.com/dnd-mcp/client/internal/models"
    "github.com/dnd-mcp/client/pkg/config"
)
```

---

## 代码格式

### 使用gofmt

```bash
# 格式化所有代码
gofmt -w -s .

# 在提交前检查
gofmt -l .
```

### 行长度

```go
// ✅ 推荐：单行不超过100字符
result := someFunction(with, many, parameters, that, make, it, very, long)

// 如果超过，换行并对齐
result := someFunction(
    with,
    many,
    parameters,
    that,
    make,
    it,
    very,
    long,
)
```

### 字符串

```go
// ✅ 推荐：使用双引号
name := "session"

// 多行字符串使用反引号
query := `
    SELECT id, name, created_at
    FROM sessions
    WHERE status = 'active'
`
```

---

## 注释规范

### 包注释

```go
// ✅ 推荐：简洁的包注释
// Package store 提供数据存储接口和实现。
package store

// ✅ 推荐：详细的包注释
/*
Package store 提供数据存储接口和实现。

支持的存储:
- Redis: 主存储，高性能
- PostgreSQL: 备份存储，持久化

使用示例:
    store := redis.NewSessionStore(client)
    session, err := store.Get(ctx, sessionID)
*/
package store
```

### 类型注释

```go
// ✅ 推荐：说明类型的用途和关键属性
// SessionStore 会话存储接口，定义会话的CRUD操作。
type SessionStore interface {
    // Create 创建新会话
    // 如果session.ID为空，会自动生成UUID
    Create(ctx context.Context, session *models.Session) error

    // Get 根据ID获取会话
    // 如果会话不存在，返回ErrSessionNotFound
    Get(ctx context.Context, id string) (*models.Session, error)
}
```

### 函数注释

```go
// ✅ 推荐：说明功能、参数、返回值、注意事项
// NewSessionStore 创建新的会话存储实例。
//
// 参数:
//   client - Redis客户端，不能为nil
//
// 返回:
//   SessionStore - 会话存储接口
//   error - 初始化失败时返回错误
//
// 示例:
//   store := NewSessionStore(redisClient)
//   session, err := store.Create(ctx, session)
func NewSessionStore(client Client) SessionStore {
    // ...
}
```

### 行内注释

```go
// ✅ 推荐：解释"为什么"而不是"是什么"
// 使用Pipeline减少网络往返
pipe := client.Client().Pipeline()

// ❌ 避免：重复代码逻辑
// 创建Pipeline
pipe := client.Client().Pipeline()
```

---

## 错误处理

### 错误定义

```go
// ✅ 推荐：预定义常见错误
var (
    ErrSessionNotFound = errors.New("session not found")
    ErrInvalidArgument = errors.New("invalid argument")
)

// ❌ 避免：每次都创建新的错误
if err != nil {
    return errors.New("session not found") // 每次都是新的错误实例
}
```

### 错误包装

```go
// ✅ 推荐：使用errors.Wrap添加上下文
if err != nil {
    return fmt.Errorf("创建会话失败: %w", err)
}

// ❌ 避免：丢失原始错误信息
if err != nil {
    return errors.New("创建会话失败") // 丢失了原始错误
}
```

### 错误比较

```go
// ✅ 推荐：使用errors.Is
if errors.Is(err, ErrSessionNotFound) {
    // 处理会话不存在
}

// ❌ 避免：字符串比较
if err.Error() == "session not found" {
    // 脆碎，容易出错
}
```

### 错误返回

```go
// ✅ 推荐：早期返回，减少嵌套
func CreateSession(ctx context.Context, req *CreateRequest) (*Session, error) {
    if req == nil {
        return nil, ErrInvalidArgument
    }
    if req.Name == "" {
        return nil, errors.New("name is required")
    }

    session := NewSession(req.Name, req.CreatorID, req.MCPServerURL)
    if err := s.store.Create(ctx, session); err != nil {
        return nil, fmt.Errorf("保存会话失败: %w", err)
    }

    return session, nil
}

// ❌ 避免：深层嵌套
func CreateSession(ctx context.Context, req *CreateRequest) (*Session, error) {
    if req != nil {
        if req.Name != "" {
            session := NewSession(req.Name, req.CreatorID, req.MCPServerURL)
            if err := s.store.Create(ctx, session); err != nil {
                return nil, err
            }
            return session, nil
        }
    }
    return nil, errors.New("invalid request")
}
```

---

## 接口设计

### 接口定义位置

```go
// ✅ 推荐：接口在使用者包中定义
// internal/store/interface.go
type SessionStore interface {
    Create(ctx context.Context, session *models.Session) error
}

// internal/store/redis/session.go
type sessionStore struct {
    client Client
}

func (s *sessionStore) Create(ctx context.Context, session *models.Session) error {
    // 实现
}
```

### 接口大小

```go
// ✅ 推荐：小而专注的接口
type SessionStore interface {
    Create(ctx context.Context, session *models.Session) error
    Get(ctx context.Context, id string) (*models.Session, error)
}

// ❌ 避免：大而全的接口
type Store interface {
    CreateSession(ctx context.Context, session *models.Session) error
    GetSession(ctx context.Context, id string) (*models.Session, error)
    CreateMessage(ctx context.Context, message *models.Message) error
    GetMessage(ctx context.Context, id string) (*models.Message, error)
    // ... 太多方法
}
```

### 接口组合

```go
// ✅ 推荐：使用接口组合
type Reader interface {
    Read(ctx context.Context, id string) ([]byte, error)
}

type Writer interface {
    Write(ctx context.Context, id string, data []byte) error
}

type ReadWriter interface {
    Reader
    Writer
}
```

---

## 测试规范

### 测试文件

```go
// ✅ 推荐：测试文件与源文件在同一目录
// internal/store/redis/session.go
// internal/store/redis/session_test.go

// 测试函数命名
func TestSessionStore_Create(t *testing.T) {...}
func TestSessionStore_Get_NotFound(t *testing.T) {...}
```

### 测试结构

```go
// ✅ 推荐：使用表驱动测试
func TestSessionStore_Create(t *testing.T) {
    tests := []struct {
        name    string
        session *models.Session
        wantErr bool
    }{
        {
            name: "成功创建会话",
            session: &models.Session{
                Name:      "测试会话",
                CreatorID: "user-123",
            },
            wantErr: false,
        },
        {
            name:     "空会话",
            session:  nil,
            wantErr:  true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 测试逻辑
        })
    }
}
```

### 测试覆盖率

```go
// ✅ 推荐：关键业务逻辑必须有测试
// 目标：>80%覆盖率

// 运行测试并查看覆盖率
go test -cover ./...

// 生成覆盖率报告
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out
```

---

## 最佳实践

### 1. 依赖注入

```go
// ✅ 推荐：通过构造函数注入依赖
type SessionService struct {
    store   store.SessionStore
    logger  Logger
    monitor *monitor.Monitor
}

func NewSessionService(
    store store.SessionStore,
    logger Logger,
    monitor *monitor.Monitor,
) *SessionService {
    return &SessionService{
        store:   store,
        logger:  logger,
        monitor: monitor,
    }
}

// ❌ 避免：全局变量或硬编码依赖
var globalStore store.SessionStore
```

### 2. Context使用

```go
// ✅ 推荐：所有阻塞操作都接受context
func (s *sessionStore) Create(ctx context.Context, session *models.Session) error {
    // 检查context是否已取消
    select {
    case <-ctx.Done():
        return ctx.Err()
    default:
    }

    // 执行操作
    return s.client.Create(ctx, session)
}

// ❌ 避免：忽略context
func (s *sessionStore) Create(session *models.Session) error {
    return s.client.Create(context.Background(), session)
}
```

### 3. 并发安全

```go
// ✅ 推荐：使用mutex保护共享状态
type StatsMonitor struct {
    mu   sync.RWMutex
    data map[string]int
}

func (s *StatsMonitor) Get(key string) int {
    s.mu.RLock()
    defer s.mu.RUnlock()
    return s.data[key]
}

func (s *StatsMonitor) Set(key string, value int) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.data[key] = value
}

// ❌ 避免：未保护的并发访问
type StatsMonitor struct {
    data map[string]int // 并发不安全
}
```

### 4. 资源清理

```go
// ✅ 推荐：使用defer确保资源释放
func ProcessSession(id string) error {
    client, err := redis.NewClient(config)
    if err != nil {
        return err
    }
    defer client.Close() // 确保关闭

    // 使用client
    return client.DoSomething()
}

// ✅ 推荐：实现Close接口
type SessionManager struct {
    db     *sql.DB
    redis  *redis.Client
}

func (m *SessionManager) Close() error {
    var errs []error

    if err := m.db.Close(); err != nil {
        errs = append(errs, err)
    }
    if err := m.redis.Close(); err != nil {
        errs = append(errs, err)
    }

    if len(errs) > 0 {
        return fmt.Errorf("关闭失败: %v", errs)
    }
    return nil
}
```

### 5. 配置管理

```go
// ✅ 推荐：使用结构体配置
type Config struct {
    RedisHost     string        `json:"redis_host"`
    RedisPort     int           `json:"redis_port"`
    ReadTimeout   time.Duration `json:"read_timeout"`
    WriteTimeout  time.Duration `json:"write_timeout"`
}

func LoadConfig() (*Config, error) {
    // 从环境变量或文件加载
    cfg := &Config{
        RedisHost:    getEnv("REDIS_HOST", "localhost:6379"),
        RedisPort:    getEnvInt("REDIS_PORT", 6379),
        ReadTimeout:  3 * time.Second,
        WriteTimeout: 3 * time.Second,
    }
    return cfg, nil
}

// ❌ 避免：散落的全局配置变量
var RedisHost = "localhost:6379"
var RedisPort = 6379
```

### 6. 日志记录

```go
// ✅ 推荐：使用结构化日志
logger.Info("会话创建成功",
    "session_id", session.ID,
    "creator_id", session.CreatorID,
    "duration_ms", time.Since(start).Milliseconds(),
)

// ✅ 推荐：记录错误时包含上下文
if err := s.store.Create(ctx, session); err != nil {
    logger.Error("创建会话失败",
        "session_id", session.ID,
        "error", err,
    )
    return fmt.Errorf("创建会话失败: %w", err)
}

// ❌ 避免：纯文本日志
log.Printf("创建会话成功: %v", session)
```

---

## 代码审查检查清单

### 提交前检查

- [ ] 代码已通过`gofmt`格式化
- [ ] 所有导出的函数和类型都有注释
- [ ] 错误处理完整，不忽略错误
- [ ] 没有硬编码的配置值
- [ ] 使用context.Context支持超时
- [ ] 共享状态有适当的并发保护
- [ ] 测试覆盖率 > 80%
- [ ] 没有调试代码（fmt.Println等）
- [ ] 没有注释掉的代码块
- [ ] 导入顺序正确（标准库 → 第三方 → 内部）

### 性能检查

- [ ] 避免在循环中分配内存
- [ ] 使用strings.Builder拼接字符串
- [ ] 预分配slice/map容量
- [ ] 使用sync.Pool复用对象
- [ ] 避免不必要的类型转换

### 安全检查

- [ ] SQL查询使用参数化
- [ ] 输入验证和清理
- [ ] 敏感信息不记录到日志
- [ ] 错误信息不泄露内部实现

---

## 工具配置

### gofmt

```bash
# 格式化所有代码
gofmt -w -s .

# 检查未格式化的文件
gofmt -l .
```

### go vet

```bash
# 运行静态分析
go vet ./...
```

### golangci-lint

```bash
# 运行代码检查
golangci-lint run
```

---

## 参考资源

- [Effective Go](https://golang.org/doc/effective_go)
- [Go Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments)
- [Go Proverbs](https://go-proverbs.github.io/)
- [Uber Go Style Guide](https://github.com/uber-go/guide)
