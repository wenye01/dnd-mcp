# D&D MCP 代码规范

## 项目结构

### 目录组织

采用标准 Go 项目布局：

- **cmd/** - 主程序入口，仅包含 main.go
- **internal/** - 私有代码，不对外暴露
  - **api/** - HTTP/WebSocket API层
  - **client/** - 外部服务客户端（LLM、MCP、数据库等）
  - **models/** - 数据模型定义
  - **orchestrator/** - 核心业务逻辑
  - **store/** - 数据持久化层
  - **cache/** - 缓存管理层
  - **config/** - 配置管理
- **pkg/** - 公共库，可被外部项目导入
- **scripts/** - 构建和部署脚本
- **doc**/ - 开发文档
- 开发进度文件应该命名为development_progress.md

### 依赖原则

1. 单向依赖：上层依赖下层，禁止下层依赖上层
2. 依赖方向：api → orchestrator → client/store/cache → models
3. internal 包不被外部导入，pkg 包可被外部使用

## 命名规范

### 基本原则

- 清晰优先于简洁，好的命名无需注释
- 同一概念使用相同命名，保持一致性
- 避免缩写，除非是通用缩写（如 id、url、http）

### 包命名

- 使用小写，单个单词
- 描述包提供的功能，使用名词
- 避免下划线、复数、过度缩写

### 文件命名

- 使用小写，下划线分隔
- 一个文件只包含一个类型（除非类型很小且密切相关）

### 变量命名

- 使用驼峰式（camelCase）
- 描述性强，避免单字母变量（除循环变量）
- 导出变量使用大写开头（PascalCase）

### 常量命名

- 使用大写，下划线分隔（UPPER_SNAKE_CASE）
- 导出常量必须大写开头

### 接口命名

- 方法名 + er 后缀（如 Reader、Writer）
- 或直接描述功能（如 SessionStore）

### 函数命名

- 使用动词开头，描述动作（如 CreateSession、ValidateCharacter）
- 导出函数使用大写开头（PascalCase）
- 多个返回值类型相同时需要命名

## 代码组织

### 文件结构顺序

1. 包声明
2. 导入包（标准库 → 第三方库 → 项目内部包）
3. 常量定义
4. 类型定义
5. 接口定义
6. 全局变量（慎用）
7. 工具函数
8. 类型方法

### 结构体定义

- 字段使用驼峰式命名
- JSON 标签使用 snake_case
- 字段按重要性排序，常用字段在前
- 必须包含结构体注释

### 接口设计

- 小接口原则：接口包含 1-3 个方法
- 单一职责：一个接口只做一件事
- 在使用方定义接口，而非实现方
- 需要多个方法时通过接口组合实现

### 函数设计

- 函数长度不超过 50 行
- 函数参数不超过 4 个，超过时使用结构体
- 职责单一，复杂逻辑拆分为多个函数
- 避免深层嵌套，使用早期返回

## 编码风格

### 格式化

- 使用 gofmt 格式化所有代码
- 不自定义格式化规则
- 提交代码前必须格式化

### 行长度

- 建议不超过 100 个字符
- 硬性限制 120 个字符

### 空行

- 函数之间空 1 行
- 逻辑块之间可空 1 行
- 不使用多余空行

### 导入分组

- 按标准库、第三方库、项目内部包分组
- 组之间空 1 行
- 删除未使用的导入

### 错误字符串

- 不大写开头
- 不包含标点符号（除非是专有名词）
- 描述具体错误原因

### 避免嵌套

- 使用早期返回避免深层嵌套
- 提前验证，错误优先处理
- 嵌套不超过 3 层

## 错误处理

### 错误处理原则

- 不要忽略错误，所有错误都必须处理
- 遇到错误立即返回，避免继续执行
- 使用 fmt.Errorf 添加错误上下文
- 错误应该返回，不是记录日志后返回 nil

### 错误包装

- 使用 %w 动词包装错误，保留原始错误类型
- 不使用 %v，避免丢失错误类型信息
- 每层添加适当的上下文信息

### 自定义错误

- 为常见错误定义类型
- 实现 Error() 方法
- 使用 errors.As 进行类型判断

### 日志记录

- 在 API 层或主程序记录日志
- 不在底层库记录日志
- 使用结构化日志，包含关键上下文（请求ID、用户ID等）

## 并发处理

### Goroutine 使用

- 明确 Goroutine 生命周期，谁创建谁负责回收
- 使用 WaitGroup 等待所有 Goroutine 完成
- 使用 context.Context 控制 Goroutine 取消
- 传递参数时避免使用循环变量的引用

### Channel 使用

- 明确缓冲大小
- 发送方负责关闭 Channel，接收方不关闭
- 确保 Goroutine 能正常退出，避免泄漏
- 避免死锁，注意发送和接收的配对

### Mutex 使用

- 减小锁粒度，只锁定必要代码
- 避免锁嵌套，防止死锁
- 使用 defer 释放锁
- 读写场景使用 RWMutex

### Context 使用

- 所有需要取消的操作都接收 Context
- Context 作为参数传递，不存储在结构体中
- 使用 Context.values 传递请求范围数据
- 及时检查 Context.Done()

## 测试规范

### 测试文件组织

- 测试文件与源文件在同一目录
- 命名为 *_test.go
- 测试函数使用 Test 前缀

### 测试命名

- 使用 Test+功能名 格式
- 具体场景使用下划线分隔（如 TestSessionCreate_InvalidInput）
- 测试名称描述被测试的功能和场景

### 测试要求

- 使用表驱动测试多个场景
- 核心业务逻辑测试覆盖率 80% 以上
- 使用接口和 Mock 避免依赖具体实现
- 测试应该是独立的，不依赖执行顺序

## 注释规范

### 包注释

- 每个包都必须有注释
- 描述包的功能和主要类型
- 放在包声明之前

### 函数注释

- 导出函数必须有注释
- 描述功能、参数、返回值
- 不需要示例代码

### 结构体注释

- 导出结构体必须有注释
- 描述结构体的用途
- 字段注释说明字段含义

### 代码注释

- 解释"为什么"而不是"做什么"
- 标记复杂逻辑、算法、临时解决方案
- 使用 TODO 标记待完成工作
- 不重复代码本身已表达的信息

## 依赖管理

### 依赖选择

- 优先使用标准库
- 选择社区活跃、维护良好的库
- 避免引入不必要的依赖
- 定期审查和更新依赖

### Go Modules

- 使用 Go Modules 管理依赖
- 定期执行 go mod tidy
- 在 go.mod 中指定主要版本
- 谨慎升级大版本

### 版本管理

- 使用语义化版本
- 固定主要版本，允许小版本更新
- 记录重要的依赖变更

## 安全与性能

### 安全考虑

- 验证所有输入
- 使用参数化查询避免 SQL 注入
- 转义用户输入避免 XSS
- 不记录敏感信息（密码、密钥等）
- 密码必须哈希存储

### 性能优化

- 避免过早优化，先保证正确性
- 使用 pprof 分析性能瓶颈
- 减少不必要的内存分配
- I/O 操作使用缓冲
- 预分配切片和 map 容量

### 代码复用

- 提取公共函数消除重复代码
- 使用接口抽象公共行为
- 避免过度抽象
- 保持代码简单直接

## 通用原则

### 代码质量

- 代码应该简洁、清晰、易读
- 优先选择简单直接的实现
- 不为了解耦而做出复杂架构
- 保持代码风格一致
- 定期重构，及时清理冗余代码

### 团队协作

- 代码审查是必须的
- 保持小步提交，频繁集成
- 编写有意义的提交信息
- 文档与代码同步更新

### 持续改进

- 定期回顾和更新规范
- 根据项目实际情况调整
- 保持规范简洁实用
- 避免教条主义

---
