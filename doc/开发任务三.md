# å¼€å‘ä»»åŠ¡ä¸‰ï¼šHTTP API - ä¼šè¯ç®¡ç†

## æ–‡æ¡£ä¿¡æ¯

- **ä»»åŠ¡ç¼–å·**: Task-3
- **ä»»åŠ¡åç§°**: HTTP API - ä¼šè¯ç®¡ç†
- **é¢„ä¼°æ—¶é—´**: 2å¤©
- **å‰ç½®ä»»åŠ¡**: Task-1ï¼ˆé¡¹ç›®è„šæ‰‹æ¶ + Redis åŸºç¡€å­˜å‚¨ï¼‰
- **åŸºäºæ–‡æ¡£**: DND_MCP_Clientè¯¦ç»†è®¾è®¡.md v1.1ã€DND_MCP_Client_å¼€å‘è®¡åˆ’.md v1.0
- **å¿…é¡»éµå®ˆ**: doc/è§„èŒƒ.md

---

## ä»»åŠ¡æ¦‚è¿°

### ç›®æ ‡

åœ¨ä»»åŠ¡ä¸€çš„åŸºç¡€ä¸Šï¼Œå®ç°ä¼šè¯ç®¡ç†çš„ REST APIï¼Œæä¾›å®Œæ•´çš„ CRUD åŠŸèƒ½ï¼Œæ”¯æŒé€šè¿‡ HTTP æ¥å£ç®¡ç†ä¼šè¯ã€‚

### åŸºäºä»»åŠ¡ä¸€çš„æˆæœ

ä»»åŠ¡ä¸€å·²å®Œæˆçš„åŸºç¡€è®¾æ–½ï¼š

- âœ… æ ‡å‡†çš„ Go é¡¹ç›®ç»“æ„ï¼ˆç¬¦åˆ `doc/è§„èŒƒ.md`ï¼‰
- âœ… Redis å­˜å‚¨å®ç°ï¼ˆ`internal/store/redis/`ï¼‰
- âœ… é¢†åŸŸæ¨¡å‹ï¼ˆ`internal/models/`ï¼‰- æœ€åº•å±‚
- âœ… é…ç½®ç®¡ç†ï¼ˆ`pkg/config/`ï¼‰
- âœ… é”™è¯¯å®šä¹‰ï¼ˆ`pkg/errors/`ï¼‰
- âœ… å‘½ä»¤è¡Œæ¡†æ¶ï¼ˆ`internal/cli/`ï¼‰
- âœ… æµ‹è¯•æ¡†æ¶ï¼ˆ`tests/`ï¼‰

### ä»»åŠ¡ä¸‰æ–°å¢åŠŸèƒ½

- ğŸŒ HTTP æœåŠ¡å™¨ï¼ˆ`internal/api/`ï¼‰
- ğŸ› ï¸ API Handler å±‚ï¼ˆ`internal/api/handler/`ï¼‰
- ğŸ“‹ è·¯ç”±ç®¡ç†ï¼ˆ`internal/api/router.go`ï¼‰
- ğŸ›¡ï¸ ä¸­é—´ä»¶ï¼ˆ`internal/api/middleware/`ï¼‰
- ğŸ“ HTTP æµ‹è¯•æ¡†æ¶ï¼ˆ`tests/integration/api/`ï¼‰

### å¯æ¼”ç¤ºåŠŸèƒ½

```bash
# å¯åŠ¨ HTTP æœåŠ¡å™¨
./bin/dnd-client server start

# åˆ›å»ºä¼šè¯
curl -X POST http://localhost:8080/api/sessions \
  -H "Content-Type: application/json" \
  -d '{
    "name": "æˆ‘çš„ç¬¬ä¸€ä¸ªæˆ˜å½¹",
    "creator_id": "user-123",
    "mcp_server_url": "http://localhost:9000",
    "max_players": 5
  }'

# è·å–ä¼šè¯åˆ—è¡¨
curl http://localhost:8080/api/sessions

# è·å–ä¼šè¯è¯¦æƒ…
curl http://localhost:8080/api/sessions/{session_id}

# æ›´æ–°ä¼šè¯
curl -X PATCH http://localhost:8080/api/sessions/{session_id} \
  -H "Content-Type: application/json" \
  -d '{"name": "æ›´æ–°çš„ä¼šè¯åç§°"}'

# åˆ é™¤ä¼šè¯
curl -X DELETE http://localhost:8080/api/sessions/{session_id}
```

### éªŒæ”¶æ ‡å‡†

- âœ… HTTP æœåŠ¡å™¨æ­£å¸¸å¯åŠ¨å’Œç›‘å¬
- âœ… æ‰€æœ‰ä¼šè¯ API æ­£å¸¸å·¥ä½œ
- âœ… HTTP çŠ¶æ€ç æ­£ç¡®
- âœ… è¯·æ±‚å‚æ•°éªŒè¯æ­£ç¡®
- âœ… é”™è¯¯å¤„ç†å’Œé”™è¯¯å“åº”ç¬¦åˆè§„èŒƒ
- âœ… æµ‹è¯•è¦†ç›–ç‡ > 80%
- âœ… ä¸¥æ ¼éµå¾ª `doc/è§„èŒƒ.md` çš„æ‰€æœ‰è¦æ±‚

---

## è§„èŒƒè¦æ±‚å¯¹ç…§æ£€æŸ¥

### ç›®å½•ç»“æ„è§„èŒƒ

éµå¾ª `doc/è§„èŒƒ.md` çš„è¦æ±‚ï¼š

```
dnd-client/
â”œâ”€â”€ cmd/                    # ä¸»ç¨‹åºå…¥å£
â”‚   â””â”€â”€ client/
â”‚       â””â”€â”€ main.go         # ç¨‹åºå…¥å£ï¼ˆä»»åŠ¡ä¸‰æ‰©å±•ï¼‰
â”œâ”€â”€ bin/                    # äºŒè¿›åˆ¶è¾“å‡ºä»¶ä½ç½®
â”œâ”€â”€ internal/               # å®ç°ä»£ç ï¼Œä¸å¯¹å¤–æš´éœ²
â”‚   â”œâ”€â”€ models/            # é¢†åŸŸæ¨¡å‹ï¼ˆä»»åŠ¡ä¸€å·²å®Œæˆï¼‰
â”‚   â”œâ”€â”€ store/             # å­˜å‚¨å®ç°å±‚ï¼ˆä»»åŠ¡ä¸€å·²å®Œæˆï¼‰
â”‚   â”‚   â””â”€â”€ redis/         # Redis å®ç°
â”‚   â”œâ”€â”€ api/               # HTTP API å±‚ï¼ˆä»»åŠ¡ä¸‰æ–°å¢ï¼‰âš ï¸
â”‚   â”‚   â”œâ”€â”€ handler/       # API å¤„ç†å™¨
â”‚   â”‚   â”‚   â””â”€â”€ session.go # ä¼šè¯ Handler
â”‚   â”‚   â”œâ”€â”€ middleware/    # ä¸­é—´ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ logging.go
â”‚   â”‚   â”‚   â”œâ”€â”€ recovery.go
â”‚   â”‚   â”‚   â””â”€â”€ cors.go
â”‚   â”‚   â””â”€â”€ router.go      # è·¯ç”±é…ç½®
â”‚   â””â”€â”€ cli/               # CLI å‘½ä»¤ï¼ˆä»»åŠ¡ä¸€å·²å®Œæˆï¼Œä»»åŠ¡ä¸‰æ‰©å±•ï¼‰
â”œâ”€â”€ pkg/                    # å…¬å…±åº“ï¼Œå¯è¢«å¤–éƒ¨é¡¹ç›®å¯¼å…¥
â”‚   â”œâ”€â”€ config/            # é…ç½®ç®¡ç†ï¼ˆä»»åŠ¡ä¸€å·²å®Œæˆï¼Œä»»åŠ¡ä¸‰æ‰©å±•ï¼‰
â”‚   â””â”€â”€ errors/            # é”™è¯¯å®šä¹‰ï¼ˆä»»åŠ¡ä¸€å·²å®Œæˆï¼Œä»»åŠ¡ä¸‰æ‰©å±•ï¼‰
â”œâ”€â”€ scripts/                # æ„å»ºå’Œéƒ¨ç½²è„šæœ¬
â”œâ”€â”€ tests/                  # æµ‹è¯•æ–‡ä»¶
â”‚   â”œâ”€â”€ unit/              # å•å…ƒæµ‹è¯•
â”‚   â”‚   â””â”€â”€ api/           # API å±‚å•å…ƒæµ‹è¯•ï¼ˆä»»åŠ¡ä¸‰æ–°å¢ï¼‰
â”‚   â”œâ”€â”€ integration/       # é›†æˆæµ‹è¯•
â”‚   â”‚   â””â”€â”€ api/           # HTTP é›†æˆæµ‹è¯•ï¼ˆä»»åŠ¡ä¸‰æ–°å¢ï¼‰
â”‚   â””â”€â”€ e2e/               # é»‘ç›’æµ‹è¯•
â”‚       â””â”€â”€ api/           # API é»‘ç›’æµ‹è¯•ï¼ˆä»»åŠ¡ä¸‰æ–°å¢ï¼‰
â””â”€â”€ doc/                    # å¼€å‘æ–‡æ¡£
```

### ä¾èµ–æ–¹å‘è§„èŒƒ

éµå¾ª `doc/è§„èŒƒ.md` çš„ä¾èµ–åŸåˆ™ï¼šå•å‘ä¾èµ–ï¼Œä¸Šå±‚ä¾èµ–ä¸‹å±‚

```
handler (HTTP å¤„ç†å™¨)
  â†“
store (å­˜å‚¨å®ç°: redis)
  â†“
models (é¢†åŸŸæ¨¡å‹) - æœ€åº•å±‚
```

**å…³é”®ç‚¹**ï¼š
- âœ… handler ä¾èµ– storeï¼ˆå…·ä½“å®ç°ï¼‰
- âœ… store ä¾èµ– modelsï¼ˆé¢†åŸŸæ¨¡å‹ï¼‰
- âœ… models ä¸ä¾èµ–ä»»ä½•å…¶ä»–åŒ…
- âœ… HTTP æµ‹è¯•ä½¿ç”¨ `httptest` åŒ…

### æ¥å£è®¾è®¡è§„èŒƒ

éµå¾ª `doc/è§„èŒƒ.md` çš„æ¥å£è®¾è®¡åŸåˆ™ï¼š
- âœ… å°æ¥å£åŸåˆ™ï¼šæ¥å£åŒ…å« 1-3 ä¸ªæ–¹æ³•
- âœ… å•ä¸€èŒè´£ï¼šä¸€ä¸ªæ¥å£åªåšä¸€ä»¶äº‹
- âœ… **Handler ä¸å®šä¹‰æ–°æ¥å£ï¼Œç›´æ¥ä½¿ç”¨ store å±‚æ¥å£**
- âœ… **ä¾èµ–æ³¨å…¥ï¼šé€šè¿‡æ„é€ å‡½æ•°æ³¨å…¥ store**

---

## éœ€æ±‚è¯¦ç»†æ‹†è§£

### éœ€æ±‚ 3.1ï¼šHTTP æœåŠ¡å™¨å’Œè·¯ç”±è®¾ç½®

#### éœ€æ±‚æè¿°

å®ç° HTTP æœåŠ¡å™¨åŸºç¡€æ¶æ„ï¼ŒåŒ…æ‹¬è·¯ç”±ç®¡ç†ã€ä¸­é—´ä»¶ã€é…ç½®ç®¡ç†ç­‰ã€‚

#### è¯¦ç»†çº¦æŸ

**1. HTTP æ¡†æ¶é€‰æ‹©**

éµå¾ª `doc/è§„èŒƒ.md` çš„ä¾èµ–é€‰æ‹©åŸåˆ™ï¼š
- é€‰æ‹©ç¤¾åŒºæ´»è·ƒã€ç»´æŠ¤è‰¯å¥½çš„åº“
- é¿å…å¼•å…¥ä¸å¿…è¦çš„ä¾èµ–

é€‰æ‹© `gin-gonic/gin` æ¡†æ¶ï¼š
- é«˜æ€§èƒ½ HTTP æ¡†æ¶
- ç¤¾åŒºæ´»è·ƒï¼ˆgithub stars 70k+ï¼‰
- API ç®€æ´æ˜“ç”¨
- å†…ç½®ä¸­é—´ä»¶ä¸°å¯Œ

**2. é…ç½®æ‰©å±•è§„èŒƒ**

åŸºäºä»»åŠ¡ä¸€çš„é…ç½®ï¼Œåœ¨ `pkg/config/config.go` ä¸­æ‰©å±•ï¼š

```go
// pkg/config/config.go

// Config åº”ç”¨é…ç½®
type Config struct {
    Redis    RedisConfig    `mapstructure:"redis"`
    HTTP     HTTPConfig     `mapstructure:"http"` // ä»»åŠ¡ä¸‰æ–°å¢
    Log      LogConfig      `mapstructure:"log"`
}

// HTTPConfig HTTP æœåŠ¡å™¨é…ç½®
type HTTPConfig struct {
    Host            string        `mapstructure:"host" env:"HTTP_HOST" default:"0.0.0.0"`
    Port            int           `mapstructure:"port" env:"HTTP_PORT" default:"8080"`
    ReadTimeout     time.Duration `mapstructure:"read_timeout" env:"HTTP_READ_TIMEOUT" default:"30s"`
    WriteTimeout    time.Duration `mapstructure:"write_timeout" env:"HTTP_WRITE_TIMEOUT" default:"30s"`
    ShutdownTimeout time.Duration `mapstructure:"shutdown_timeout" env:"HTTP_SHUTDOWN_TIMEOUT" default:"10s"`
    EnableCORS      bool          `mapstructure:"enable_cors" env:"HTTP_ENABLE_CORS" default:"true"`
}
```

**3. æœåŠ¡å™¨æ¶æ„è®¾è®¡**

```go
// internal/api/server.go

// Package api æä¾› HTTP API æœåŠ¡
package api

import (
    "context"
    "fmt"
    "net/http"
    "time"

    "github.com/gin-gonic/gin"
    "dnd-client/internal/store"
    "dnd-client/pkg/config"
    "dnd-client/pkg/logger"
)

// Server HTTP æœåŠ¡å™¨
type Server struct {
    config     *config.Config
    httpServer *http.Server
    router     *gin.Engine
    sessionStore store.SessionStore // ä¾èµ–æ³¨å…¥
}

// NewServer åˆ›å»º HTTP æœåŠ¡å™¨
func NewServer(
    cfg *config.Config,
    sessionStore store.SessionStore,
) *Server {
    // è®¾ç½® Gin æ¨¡å¼
    if cfg.Log.Level == "debug" {
        gin.SetMode(gin.DebugMode)
    } else {
        gin.SetMode(gin.ReleaseMode)
    }

    router := gin.New()

    server := &Server{
        config:       cfg,
        router:       router,
        sessionStore: sessionStore,
    }

    // è®¾ç½®ä¸­é—´ä»¶
    server.setupMiddleware()

    // è®¾ç½®è·¯ç”±
    server.setupRoutes()

    return server
}

// setupMiddleware è®¾ç½®ä¸­é—´ä»¶
func (s *Server) setupMiddleware() {
    // æ—¥å¿—ä¸­é—´ä»¶
    s.router.Use(middleware.Logger(logger.Instance))

    // å¼‚å¸¸æ¢å¤ä¸­é—´ä»¶
    s.router.Use(middleware.Recovery(logger.Instance))

    // CORS ä¸­é—´ä»¶
    if s.config.HTTP.EnableCORS {
        s.router.Use(middleware.CORS())
    }
}

// setupRoutes è®¾ç½®è·¯ç”±
func (s *Server) setupRoutes() {
    // å¥åº·æ£€æŸ¥
    s.router.GET("/health", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{"status": "ok"})
    })

    // API è·¯ç”±ç»„
    api := s.router.Group("/api")
    {
        // ä¼šè¯è·¯ç”±ï¼ˆéœ€æ±‚ 3.2-3.6ï¼‰
        sessions := api.Group("/sessions")
        {
            sessions.POST("", handler.CreateSession(s.sessionStore))
            sessions.GET("", handler.ListSessions(s.sessionStore))
            sessions.GET("/:id", handler.GetSession(s.sessionStore))
            sessions.PATCH("/:id", handler.UpdateSession(s.sessionStore))
            sessions.DELETE("/:id", handler.DeleteSession(s.sessionStore))
        }
    }
}

// Start å¯åŠ¨ HTTP æœåŠ¡å™¨
func (s *Server) Start() error {
    addr := fmt.Sprintf("%s:%d", s.config.HTTP.Host, s.config.HTTP.Port)

    s.httpServer = &http.Server{
        Addr:         addr,
        Handler:      s.router,
        ReadTimeout:  s.config.HTTP.ReadTimeout,
        WriteTimeout: s.config.HTTP.WriteTimeout,
    }

    logger.Info("HTTP æœåŠ¡å™¨å¯åŠ¨",
        "addr", addr,
        "timeout", s.config.HTTP.ReadTimeout,
    )

    if err := s.httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
        return fmt.Errorf("HTTP æœåŠ¡å™¨å¯åŠ¨å¤±è´¥: %w", err)
    }

    return nil
}

// Shutdown ä¼˜é›…å…³é—­ HTTP æœåŠ¡å™¨
func (s *Server) Shutdown(ctx context.Context) error {
    logger.Info("HTTP æœåŠ¡å™¨æ­£åœ¨å…³é—­...")

    shutdownCtx, cancel := context.WithTimeout(ctx, s.config.HTTP.ShutdownTimeout)
    defer cancel()

    if err := s.httpServer.Shutdown(shutdownCtx); err != nil {
        return fmt.Errorf("HTTP æœåŠ¡å™¨å…³é—­å¤±è´¥: %w", err)
    }

    logger.Info("HTTP æœåŠ¡å™¨å·²å…³é—­")
    return nil
}
```

**4. ä¸­é—´ä»¶å®ç°**

```go
// internal/api/middleware/logging.go

// Package middleware æä¾› HTTP ä¸­é—´ä»¶
package middleware

import (
    "time"

    "github.com/gin-gonic/gin"
    "dnd-client/pkg/logger"
)

// Logger æ—¥å¿—ä¸­é—´ä»¶
func Logger(log *logger.Logger) gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        path := c.Request.URL.Path
        query := c.Request.URL.RawQuery

        c.Next()

        latency := time.Since(start)
        status := c.Writer.Status()

        log.Info("HTTP è¯·æ±‚",
            "method", c.Request.Method,
            "path", path,
            "query", query,
            "status", status,
            "latency", latency,
            "ip", c.ClientIP(),
        )
    }
}
```

```go
// internal/api/middleware/recovery.go

// Package middleware æä¾› HTTP ä¸­é—´ä»¶
package middleware

import (
    "net/http"

    "github.com/gin-gonic/gin"
    "dnd-client/pkg/logger"
)

// Recovery å¼‚å¸¸æ¢å¤ä¸­é—´ä»¶
func Recovery(log *logger.Logger) gin.HandlerFunc {
    return func(c *gin.Context) {
        defer func() {
            if err := recover(); err != nil {
                log.Error("HTTP panic",
                    "error", err,
                    "path", c.Request.URL.Path,
                )

                c.JSON(http.StatusInternalServerError, gin.H{
                    "error": gin.H{
                        "code":    "INTERNAL_SERVER_ERROR",
                        "message": "æœåŠ¡å™¨å†…éƒ¨é”™è¯¯",
                    },
                })
                c.Abort()
            }
        }()

        c.Next()
    }
}
```

```go
// internal/api/middleware/cors.go

// Package middleware æä¾› HTTP ä¸­é—´ä»¶
package middleware

import (
    "github.com/gin-gonic/gin"
)

// CORS è·¨åŸŸä¸­é—´ä»¶
func CORS() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
        c.Writer.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS")
        c.Writer.Header().Set("Access-Control-Allow-Headers", "Origin, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization")
        c.Writer.Header().Set("Access-Control-Expose-Headers", "Content-Length")
        c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")

        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(http.StatusNoContent)
            return
        }

        c.Next()
    }
}
```

**5. CLI å‘½ä»¤æ‰©å±•**

```go
// internal/cli/server.go

// Package cli æä¾›å‘½ä»¤è¡Œå·¥å…·
package cli

import (
    "os"
    "os/signal"
    "syscall"

    "github.com/spf13/cobra"
    "dnd-client/internal/api"
    "dnd-client/internal/store/redis"
    "dnd-client/pkg/config"
    "dnd-client/pkg/logger"
)

// serverCmd å¯åŠ¨ HTTP æœåŠ¡å™¨
var serverCmd = &cobra.Command{
    Use:   "server",
    Short: "å¯åŠ¨ HTTP æœåŠ¡å™¨",
    Long:  `å¯åŠ¨ HTTP API æœåŠ¡å™¨`,
    RunE: func(cmd *cobra.Command, args []string) error {
        // åŠ è½½é…ç½®
        cfg, err := config.Load()
        if err != nil {
            return err
        }

        // åˆå§‹åŒ–æ—¥å¿—
        if err := logger.Init(cfg.Log); err != nil {
            return err
        }

        // åˆå§‹åŒ– Redis
        redisClient, err := redis.NewClient(cfg.Redis)
        if err != nil {
            return err
        }
        defer redisClient.Close()

        // åˆ›å»º Session Store
        sessionStore := redis.NewSessionStore(redisClient)

        // åˆ›å»º HTTP æœåŠ¡å™¨
        server := api.NewServer(cfg, sessionStore)

        // å¯åŠ¨æœåŠ¡å™¨ï¼ˆåå°ï¼‰
        go func() {
            if err := server.Start(); err != nil {
                logger.Fatal("HTTP æœåŠ¡å™¨å¯åŠ¨å¤±è´¥", "error", err)
            }
        }()

        // ç­‰å¾…é€€å‡ºä¿¡å·
        quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        <-quit

        logger.Info("æ”¶åˆ°å…³é—­ä¿¡å·ï¼Œæ­£åœ¨ä¼˜é›…å…³é—­...")

        // ä¼˜é›…å…³é—­ HTTP æœåŠ¡å™¨
        ctx := cmd.Context()
        if err := server.Shutdown(ctx); err != nil {
            logger.Error("HTTP æœåŠ¡å™¨å…³é—­å¤±è´¥", "error", err)
        }

        return nil
    },
}

func init() {
    rootCmd.AddCommand(serverCmd)
}
```

#### æŠ€æœ¯è¦æ±‚

**1. ä¼˜é›…å…³é—­**

- æ•è· SIGTERM/SIGINT ä¿¡å·
- è®¾ç½®è¶…æ—¶æ—¶é—´ï¼ˆé»˜è®¤ 10 ç§’ï¼‰
- ç­‰å¾…ç°æœ‰è¯·æ±‚å®Œæˆ
- è¶…æ—¶åå¼ºåˆ¶å…³é—­

**2. ä¾èµ–æ³¨å…¥**

- é€šè¿‡æ„é€ å‡½æ•°æ³¨å…¥ store
- é¿å…å…¨å±€å˜é‡
- ä¾¿äºæµ‹è¯•

**3. é…ç½®ç®¡ç†**

- æ”¯æŒç¯å¢ƒå˜é‡è¦†ç›–
- æä¾›åˆç†é»˜è®¤å€¼
- é…ç½®éªŒè¯

#### æ–‡ä»¶æ¸…å•

- [ ] `pkg/config/config.go` - é…ç½®æ‰©å±•ï¼ˆæ·»åŠ  HTTPï¼‰
- [ ] `internal/api/server.go` - HTTP æœåŠ¡å™¨
- [ ] `internal/api/router.go` - è·¯ç”±é…ç½®
- [ ] `internal/api/middleware/logging.go` - æ—¥å¿—ä¸­é—´ä»¶
- [ ] `internal/api/middleware/recovery.go` - æ¢å¤ä¸­é—´ä»¶
- [ ] `internal/api/middleware/cors.go` - CORS ä¸­é—´ä»¶
- [ ] `internal/cli/server.go` - server å‘½ä»¤
- [ ] `.env.example` - ç¯å¢ƒå˜é‡ç¤ºä¾‹æ›´æ–°

#### æµ‹è¯•è¦æ±‚

**æµ‹è¯•ä½ç½®è§„èŒƒ**ï¼šæ‰€æœ‰æµ‹è¯•å¿…é¡»åœ¨ `tests/` ç›®å½•ä¸‹

**å•å…ƒæµ‹è¯•**

- [ ] `tests/unit/api/server_test.go`
  - Mock SessionStore
  - æµ‹è¯•æœåŠ¡å™¨åˆ›å»º
  - æµ‹è¯•ä¸­é—´ä»¶æ³¨å†Œ
  - æµ‹è¯•è·¯ç”±æ³¨å†Œ

- [ ] `tests/unit/api/middleware/logging_test.go`
  - æµ‹è¯•æ—¥å¿—è®°å½•
  - éªŒè¯è¯·æ±‚è€—æ—¶

- [ ] `tests/unit/api/middleware/recovery_test.go`
  - æµ‹è¯• panic æ¢å¤
  - éªŒè¯é”™è¯¯å“åº”

- [ ] `tests/unit/api/middleware/cors_test.go`
  - æµ‹è¯• CORS å¤´
  - æµ‹è¯• OPTIONS è¯·æ±‚

**é›†æˆæµ‹è¯•**

- [ ] `tests/integration/api/server_integration_test.go`
  - æµ‹è¯•æœåŠ¡å™¨å¯åŠ¨
  - æµ‹è¯•æœåŠ¡å™¨å…³é—­
  - æµ‹è¯•ä¼˜é›…å…³é—­

---

### éœ€æ±‚ 3.2ï¼šåˆ›å»ºä¼šè¯ API (POST /api/sessions)

#### éœ€æ±‚æè¿°

å®ç°åˆ›å»ºä¼šè¯çš„ POST APIï¼Œæ”¯æŒå‚æ•°éªŒè¯ã€æ•°æ®å­˜å‚¨ã€çŠ¶æ€ç è¿”å›ã€‚

#### è¯¦ç»†çº¦æŸ

**1. API è§„èŒƒ**

ä¸¥æ ¼éµå¾ª `DND_MCP_Clientè¯¦ç»†è®¾è®¡.md` çš„ API è®¾è®¡ï¼š

```
POST /api/sessions
Content-Type: application/json

è¯·æ±‚ä½“:
{
  "name": "æˆ‘çš„ç¬¬ä¸€ä¸ªæˆ˜å½¹",           // å¿…å¡«ï¼Œä¼šè¯åç§°
  "creator_id": "user-123",          // å¿…å¡«ï¼Œåˆ›å»ºè€…ID
  "mcp_server_url": "http://localhost:9000",  // å¿…å¡«ï¼ŒMCP Server URL
  "max_players": 5,                  // å¯é€‰ï¼Œæœ€å¤§ç©å®¶æ•°ï¼Œé»˜è®¤4
  "settings": {                      // å¯é€‰ï¼Œä¼šè¯é…ç½®
    "ruleset": "dnd5e",
    "starting_level": 1
  }
}

å“åº”: 201 Created
{
  "id": "session-uuid-xxx",
  "name": "æˆ‘çš„ç¬¬ä¸€ä¸ªæˆ˜å½¹",
  "creator_id": "user-123",
  "mcp_server_url": "http://localhost:9000",
  "websocket_key": "ws-key-xxx",
  "max_players": 5,
  "settings": {...},
  "created_at": "2025-02-03T10:00:00Z",
  "updated_at": "2025-02-03T10:00:00Z",
  "status": "active"
}

é”™è¯¯å“åº”:
  400 Bad Request - å‚æ•°éªŒè¯å¤±è´¥
  503 Service Unavailable - Redis è¿æ¥å¤±è´¥
```

**2. Handler å®ç°**

```go
// internal/api/handler/session.go

// Package handler æä¾› HTTP å¤„ç†å™¨
package handler

import (
    "net/http"

    "github.com/gin-gonic/gin"
    "github.com/google/uuid"

    "dnd-client/internal/models"
    "dnd-client/internal/store"
    "dnd-client/pkg/errors"
)

// CreateSessionRequest åˆ›å»ºä¼šè¯è¯·æ±‚
type CreateSessionRequest struct {
    Name         string                 `json:"name" binding:"required"`
    CreatorID    string                 `json:"creator_id" binding:"required"`
    MCPServerURL string                 `json:"mcp_server_url" binding:"required,url"`
    MaxPlayers   int                    `json:"max_players"`
    Settings     map[string]interface{} `json:"settings"`
}

// SessionResponse ä¼šè¯å“åº”
type SessionResponse struct {
    ID           string                 `json:"id"`
    Name         string                 `json:"name"`
    CreatorID    string                 `json:"creator_id"`
    MCPServerURL string                 `json:"mcp_server_url"`
    WebSocketKey string                 `json:"websocket_key"`
    MaxPlayers   int                    `json:"max_players"`
    Settings     map[string]interface{} `json:"settings"`
    CreatedAt    string                 `json:"created_at"`
    UpdatedAt    string                 `json:"updated_at"`
    Status       string                 `json:"status"`
}

// CreateSession åˆ›å»ºä¼šè¯ Handler
func CreateSession(sessionStore store.SessionStore) gin.HandlerFunc {
    return func(c *gin.Context) {
        var req CreateSessionRequest

        // å‚æ•°ç»‘å®šå’ŒéªŒè¯
        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{
                "error": gin.H{
                    "code":    "INVALID_REQUEST",
                    "message": "è¯·æ±‚å‚æ•°é”™è¯¯",
                    "details": err.Error(),
                },
            })
            return
        }

        // å‚æ•°éªŒè¯
        if req.MaxPlayers < 1 || req.MaxPlayers > 10 {
            c.JSON(http.StatusBadRequest, gin.H{
                "error": gin.H{
                    "code":    "INVALID_MAX_PLAYERS",
                    "message": "max_players å¿…é¡»åœ¨ 1-10 ä¹‹é—´",
                },
            })
            return
        }

        // é»˜è®¤å€¼
        if req.MaxPlayers == 0 {
            req.MaxPlayers = 4
        }

        // ç”Ÿæˆä¼šè¯
        sessionID := uuid.New().String()
        wsKey := generateWebSocketKey()

        session := &models.Session{
            ID:           sessionID,
            Name:         req.Name,
            CreatorID:    req.CreatorID,
            MCPServerURL: req.MCPServerURL,
            WebSocketKey: wsKey,
            MaxPlayers:   req.MaxPlayers,
            Settings:     req.Settings,
            CreatedAt:    time.Now(),
            UpdatedAt:    time.Now(),
            Status:       "active",
        }

        // ä¿å­˜åˆ° Redis
        if err := sessionStore.Create(c.Request.Context(), session); err != nil {
            // åˆ¤æ–­é”™è¯¯ç±»å‹
            if errors.Is(err, errors.ErrRedisConnectionFailed) {
                c.JSON(http.StatusServiceUnavailable, gin.H{
                    "error": gin.H{
                        "code":    "REDIS_UNAVAILABLE",
                        "message": "Redis è¿æ¥å¤±è´¥",
                    },
                })
                return
            }

            c.JSON(http.StatusInternalServerError, gin.H{
                "error": gin.H{
                    "code":    "INTERNAL_ERROR",
                    "message": "åˆ›å»ºä¼šè¯å¤±è´¥",
                },
            })
            return
        }

        // è¿”å› 201 Created
        c.JSON(http.StatusCreated, toSessionResponse(session))
    }
}

// generateWebSocketKey ç”Ÿæˆ WebSocket å¯†é’¥
func generateWebSocketKey() string {
    return "ws-" + uuid.New().String()
}

// toSessionResponse è½¬æ¢ä¸ºå“åº”æ ¼å¼
func toSessionResponse(session *models.Session) SessionResponse {
    return SessionResponse{
        ID:           session.ID,
        Name:         session.Name,
        CreatorID:    session.CreatorID,
        MCPServerURL: session.MCPServerURL,
        WebSocketKey: session.WebSocketKey,
        MaxPlayers:   session.MaxPlayers,
        Settings:     session.Settings,
        CreatedAt:    session.CreatedAt.Format(time.RFC3339),
        UpdatedAt:    session.UpdatedAt.Format(time.RFC3339),
        Status:       session.Status,
    }
}
```

**3. é”™è¯¯å¤„ç†è§„èŒƒ**

éµå¾ª `doc/è§„èŒƒ.md` çš„é”™è¯¯å¤„ç†åŸåˆ™ï¼š
- æä¾›æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯
- é”™è¯¯åº”è¯¥è¿”å›ï¼Œä¸æ˜¯è®°å½•æ—¥å¿—åè¿”å› nil
- ä½¿ç”¨ç»“æ„åŒ–é”™è¯¯å“åº”

**é”™è¯¯å“åº”æ ¼å¼**ï¼š

```json
{
  "error": {
    "code": "INVALID_REQUEST",
    "message": "è¯·æ±‚å‚æ•°é”™è¯¯",
    "details": "name æ˜¯å¿…å¡«å­—æ®µ",
    "timestamp": "2025-02-03T10:00:00Z",
    "request_id": "req-uuid-xxx"
  }
}
```

#### æŠ€æœ¯è¦æ±‚

**1. å‚æ•°éªŒè¯**

- ä½¿ç”¨ Gin çš„ binding éªŒè¯
- è‡ªå®šä¹‰ä¸šåŠ¡é€»è¾‘éªŒè¯
- æä¾›æ¸…æ™°çš„é”™è¯¯æç¤º

**2. çŠ¶æ€ç è§„èŒƒ**

- 201 Created - åˆ›å»ºæˆåŠŸ
- 400 Bad Request - å‚æ•°é”™è¯¯
- 500 Internal Server Error - æœåŠ¡å™¨é”™è¯¯
- 503 Service Unavailable - Redis ä¸å¯ç”¨

**3. æ—¶é—´æ ¼å¼**

- ç»Ÿä¸€ä½¿ç”¨ RFC3339 æ ¼å¼
- æ—¶åŒºä½¿ç”¨ UTC

#### æ–‡ä»¶æ¸…å•

- [ ] `internal/api/handler/session.go` - ä¼šè¯ Handler
- [ ] `internal/api/router.go` - è·¯ç”±æ³¨å†Œ
- [ ] `pkg/errors/errors.go` - é”™è¯¯å®šä¹‰æ‰©å±•

#### æµ‹è¯•è¦æ±‚

**HTTP æµ‹è¯•ï¼ˆä½¿ç”¨ httptestï¼‰**

- [ ] `tests/integration/api/session_test.go`
  - æµ‹è¯•åˆ›å»ºä¼šè¯æˆåŠŸ
  - æµ‹è¯•å‚æ•°éªŒè¯ï¼ˆç¼ºå°‘å¿…å¡«å­—æ®µï¼‰
  - æµ‹è¯•å‚æ•°éªŒè¯ï¼ˆæ ¼å¼é”™è¯¯ï¼‰
  - æµ‹è¯• Redis è¿æ¥å¤±è´¥
  - æµ‹è¯•é»˜è®¤å€¼è®¾ç½®
  - æµ‹è¯•å“åº”æ ¼å¼

**æµ‹è¯•ç¤ºä¾‹**ï¼š

```go
// tests/integration/api/session_test.go

func TestCreateSession(t *testing.T) {
    // è®¾ç½®æµ‹è¯•ç¯å¢ƒ
    redisClient := setupTestRedis(t)
    defer cleanupTestRedis(t, redisClient)

    sessionStore := redis.NewSessionStore(redisClient)
    router := setupRouter(sessionStore)

    // æµ‹è¯•åˆ›å»ºä¼šè¯
    t.Run("åˆ›å»ºä¼šè¯æˆåŠŸ", func(t *testing.T) {
        reqBody := `{
            "name": "æµ‹è¯•ä¼šè¯",
            "creator_id": "user-123",
            "mcp_server_url": "http://localhost:9000",
            "max_players": 5
        }`

        req := httptest.NewRequest("POST", "/api/sessions", strings.NewReader(reqBody))
        req.Header.Set("Content-Type", "application/json")
        w := httptest.NewRecorder()

        router.ServeHTTP(w, req)

        assert.Equal(t, http.StatusCreated, w.Code)

        var resp SessionResponse
        err := json.Unmarshal(w.Body.Bytes(), &resp)
        assert.NoError(t, err)
        assert.NotEmpty(t, resp.ID)
        assert.Equal(t, "æµ‹è¯•ä¼šè¯", resp.Name)
    })

    t.Run("ç¼ºå°‘å¿…å¡«å­—æ®µ", func(t *testing.T) {
        reqBody := `{"name": "æµ‹è¯•ä¼šè¯"}` // ç¼ºå°‘ creator_id å’Œ mcp_server_url

        req := httptest.NewRequest("POST", "/api/sessions", strings.NewReader(reqBody))
        req.Header.Set("Content-Type", "application/json")
        w := httptest.NewRecorder()

        router.ServeHTTP(w, req)

        assert.Equal(t, http.StatusBadRequest, w.Code)
    })
}
```

---

### éœ€æ±‚ 3.3ï¼šè·å–ä¼šè¯è¯¦æƒ… API (GET /api/sessions/{id})

#### éœ€æ±‚æè¿°

å®ç°è·å–å•ä¸ªä¼šè¯è¯¦æƒ…çš„ GET APIï¼Œæ”¯æŒä¼šè¯ä¸å­˜åœ¨æ—¶è¿”å› 404ã€‚

#### è¯¦ç»†çº¦æŸ

**1. API è§„èŒƒ**

```
GET /api/sessions/{session_id}

è·¯å¾„å‚æ•°:
  session_id: ä¼šè¯ID (UUID)

å“åº”: 200 OK
{
  "id": "session-uuid-xxx",
  "name": "æˆ‘çš„ç¬¬ä¸€ä¸ªæˆ˜å½¹",
  "creator_id": "user-123",
  "mcp_server_url": "http://localhost:9000",
  "max_players": 5,
  "current_players": 3,
  "settings": {...},
  "created_at": "2025-02-03T10:00:00Z",
  "updated_at": "2025-02-03T10:05:00Z",
  "status": "active",
  "message_count": 120
}

é”™è¯¯å“åº”:
  404 Not Found - ä¼šè¯ä¸å­˜åœ¨
```

**2. Handler å®ç°**

```go
// internal/api/handler/session.go

// GetSession è·å–ä¼šè¯è¯¦æƒ… Handler
func GetSession(sessionStore store.SessionStore) gin.HandlerFunc {
    return func(c *gin.Context) {
        // è·å–è·¯å¾„å‚æ•°
        sessionID := c.Param("id")

        // éªŒè¯ UUID æ ¼å¼
        if _, err := uuid.Parse(sessionID); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{
                "error": gin.H{
                    "code":    "INVALID_SESSION_ID",
                    "message": "ä¼šè¯IDæ ¼å¼é”™è¯¯",
                },
            })
            return
        }

        // ä» Redis æŸ¥è¯¢
        session, err := sessionStore.Get(c.Request.Context(), sessionID)
        if err != nil {
            if errors.Is(err, errors.ErrSessionNotFound) {
                c.JSON(http.StatusNotFound, gin.H{
                    "error": gin.H{
                        "code":    "SESSION_NOT_FOUND",
                        "message": "ä¼šè¯ä¸å­˜åœ¨",
                    },
                })
                return
            }

            c.JSON(http.StatusInternalServerError, gin.H{
                "error": gin.H{
                    "code":    "INTERNAL_ERROR",
                    "message": "æŸ¥è¯¢ä¼šè¯å¤±è´¥",
                },
            })
            return
        }

        // è¿”å›ä¼šè¯è¯¦æƒ…
        c.JSON(http.StatusOK, toSessionResponse(session))
    }
}
```

#### æµ‹è¯•è¦æ±‚

- [ ] æµ‹è¯•è·å–å­˜åœ¨çš„ä¼šè¯è¿”å› 200
- [ ] æµ‹è¯•è·å–ä¸å­˜åœ¨çš„ä¼šè¯è¿”å› 404
- [ ] æµ‹è¯• UUID æ ¼å¼éªŒè¯
- [ ] æµ‹è¯• Redis æŸ¥è¯¢å¤±è´¥

---

### éœ€æ±‚ 3.4ï¼šåˆ—å‡ºæ‰€æœ‰ä¼šè¯ API (GET /api/sessions)

#### éœ€æ±‚æè¿°

å®ç°è·å–ä¼šè¯åˆ—è¡¨çš„ GET APIï¼Œæ”¯æŒçŠ¶æ€è¿‡æ»¤ã€‚

#### è¯¦ç»†çº¦æŸ

**1. API è§„èŒƒ**

```
GET /api/sessions

æŸ¥è¯¢å‚æ•°:
  status: çŠ¶æ€è¿‡æ»¤ï¼ˆå¯é€‰ï¼‰ï¼Œactive | archivedï¼Œé»˜è®¤ active

ç¤ºä¾‹:
  GET /api/sessions
  GET /api/sessions?status=archived

å“åº”: 200 OK
[
  {
    "id": "session-uuid-1",
    "name": "æˆ‘çš„ç¬¬ä¸€ä¸ªæˆ˜å½¹",
    "creator_id": "user-123",
    "current_players": 3,
    "message_count": 120,
    "created_at": "2025-02-03T10:00:00Z",
    "updated_at": "2025-02-03T10:05:00Z",
    "status": "active"
  },
  ...
]

è¯´æ˜:
  â€¢ ç›´æ¥è¿”å›ä¼šè¯æ•°ç»„ï¼Œæ— åˆ†é¡µ
  â€¢ æŒ‰ created_at å€’åºæ’åˆ—
  â€¢ é€‚ç”¨äºä¼šè¯æ•°é‡è¾ƒå°‘çš„åœºæ™¯ï¼ˆ< 100 ä¸ªï¼‰
```

**2. Handler å®ç°**

```go
// internal/api/handler/session.go

// ListSessions åˆ—å‡ºæ‰€æœ‰ä¼šè¯ Handler
func ListSessions(sessionStore store.SessionStore) gin.HandlerFunc {
    return func(c *gin.Context) {
        // è·å–æŸ¥è¯¢å‚æ•°
        status := c.DefaultQuery("status", "active")

        // éªŒè¯ status å‚æ•°
        if status != "active" && status != "archived" {
            c.JSON(http.StatusBadRequest, gin.H{
                "error": gin.H{
                    "code":    "INVALID_STATUS",
                    "message": "status å‚æ•°å¿…é¡»æ˜¯ active æˆ– archived",
                },
            })
            return
        }

        // ä» Redis æŸ¥è¯¢
        sessions, err := sessionStore.List(c.Request.Context())
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{
                "error": gin.H{
                    "code":    "INTERNAL_ERROR",
                    "message": "æŸ¥è¯¢ä¼šè¯åˆ—è¡¨å¤±è´¥",
                },
            })
            return
        }

        // è¿‡æ»¤çŠ¶æ€
        var filtered []*models.Session
        for _, session := range sessions {
            if session.Status == status {
                filtered = append(filtered, session)
            }
        }

        // è½¬æ¢ä¸ºå“åº”æ ¼å¼
        response := make([]SessionResponse, len(filtered))
        for i, session := range filtered {
            response[i] = toSessionResponse(session)
        }

        // è¿”å›åˆ—è¡¨
        c.JSON(http.StatusOK, response)
    }
}
```

#### æµ‹è¯•è¦æ±‚

- [ ] æµ‹è¯•è·å–æ‰€æœ‰æ´»è·ƒä¼šè¯
- [ ] æµ‹è¯•æŒ‰çŠ¶æ€è¿‡æ»¤
- [ ] æµ‹è¯•æ— æ•ˆ status å‚æ•°
- [ ] æµ‹è¯•ç©ºåˆ—è¡¨
- [ ] æµ‹è¯•å¤šä¸ªä¼šè¯æ’åº

---

### éœ€æ±‚ 3.5ï¼šæ›´æ–°ä¼šè¯ API (PATCH /api/sessions/{id})

#### éœ€æ±‚æè¿°

å®ç°æ›´æ–°ä¼šè¯çš„ PATCH APIï¼Œæ”¯æŒéƒ¨åˆ†æ›´æ–°ã€‚

#### è¯¦ç»†çº¦æŸ

**1. API è§„èŒƒ**

```
PATCH /api/sessions/{session_id}

è¯·æ±‚ä½“:
{
  "name": "æ–°çš„ä¼šè¯åç§°",
  "max_players": 6,
  "settings": {
    "ruleset": "dnd5e"
  }
}

å“åº”: 200 OK
{
  "id": "session-uuid-xxx",
  "name": "æ–°çš„ä¼šè¯åç§°",
  ...
}

é”™è¯¯å“åº”:
  404 Not Found - ä¼šè¯ä¸å­˜åœ¨
  400 Bad Request - å‚æ•°éªŒè¯å¤±è´¥
```

**2. Handler å®ç°**

```go
// internal/api/handler/session.go

// UpdateSessionRequest æ›´æ–°ä¼šè¯è¯·æ±‚
type UpdateSessionRequest struct {
    Name       *string                 `json:"name"`
    MaxPlayers *int                    `json:"max_players"`
    Settings   map[string]interface{} `json:"settings"`
}

// UpdateSession æ›´æ–°ä¼šè¯ Handler
func UpdateSession(sessionStore store.SessionStore) gin.HandlerFunc {
    return func(c *gin.Context) {
        sessionID := c.Param("id")

        // éªŒè¯ UUID æ ¼å¼
        if _, err := uuid.Parse(sessionID); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{
                "error": gin.H{
                    "code":    "INVALID_SESSION_ID",
                    "message": "ä¼šè¯IDæ ¼å¼é”™è¯¯",
                },
            })
            return
        }

        var req UpdateSessionRequest
        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{
                "error": gin.H{
                    "code":    "INVALID_REQUEST",
                    "message": "è¯·æ±‚å‚æ•°é”™è¯¯",
                },
            })
            return
        }

        // è·å–ç°æœ‰ä¼šè¯
        session, err := sessionStore.Get(c.Request.Context(), sessionID)
        if err != nil {
            if errors.Is(err, errors.ErrSessionNotFound) {
                c.JSON(http.StatusNotFound, gin.H{
                    "error": gin.H{
                        "code":    "SESSION_NOT_FOUND",
                        "message": "ä¼šè¯ä¸å­˜åœ¨",
                    },
                })
                return
            }
            // ... å…¶ä»–é”™è¯¯å¤„ç†
        }

        // éƒ¨åˆ†æ›´æ–°
        if req.Name != nil {
            session.Name = *req.Name
        }
        if req.MaxPlayers != nil {
            if *req.MaxPlayers < 1 || *req.MaxPlayers > 10 {
                c.JSON(http.StatusBadRequest, gin.H{
                    "error": gin.H{
                        "code":    "INVALID_MAX_PLAYERS",
                        "message": "max_players å¿…é¡»åœ¨ 1-10 ä¹‹é—´",
                    },
                })
                return
            }
            session.MaxPlayers = *req.MaxPlayers
        }
        if req.Settings != nil {
            session.Settings = req.Settings
        }
        session.UpdatedAt = time.Now()

        // ä¿å­˜æ›´æ–°
        if err := sessionStore.Update(c.Request.Context(), session); err != nil {
            // ... é”™è¯¯å¤„ç†
        }

        // è¿”å›æ›´æ–°åçš„ä¼šè¯
        c.JSON(http.StatusOK, toSessionResponse(session))
    }
}
```

#### æµ‹è¯•è¦æ±‚

- [ ] æµ‹è¯•æ›´æ–°åç§°
- [ ] æµ‹è¯•æ›´æ–° max_players
- [ ] æµ‹è¯•æ›´æ–° settings
- [ ] æµ‹è¯•éƒ¨åˆ†æ›´æ–°
- [ ] æµ‹è¯•ä¼šè¯ä¸å­˜åœ¨è¿”å› 404
- [ ] æµ‹è¯•å‚æ•°éªŒè¯

---

### éœ€æ±‚ 3.6ï¼šåˆ é™¤ä¼šè¯ API (DELETE /api/sessions/{id})

#### éœ€æ±‚æè¿°

å®ç°åˆ é™¤ä¼šè¯çš„ DELETE APIï¼Œä½¿ç”¨è½¯åˆ é™¤ã€‚

#### è¯¦ç»†çº¦æŸ

**1. API è§„èŒƒ**

```
DELETE /api/sessions/{session_id}

å“åº”: 204 No Content

é”™è¯¯å“åº”:
  404 Not Found - ä¼šè¯ä¸å­˜åœ¨
```

**2. Handler å®ç°**

```go
// internal/api/handler/session.go

// DeleteSession åˆ é™¤ä¼šè¯ Handler
func DeleteSession(sessionStore store.SessionStore) gin.HandlerFunc {
    return func(c *gin.Context) {
        sessionID := c.Param("id")

        // éªŒè¯ UUID æ ¼å¼
        if _, err := uuid.Parse(sessionID); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{
                "error": gin.H{
                    "code":    "INVALID_SESSION_ID",
                    "message": "ä¼šè¯IDæ ¼å¼é”™è¯¯",
                },
            })
            return
        }

        // æ£€æŸ¥ä¼šè¯æ˜¯å¦å­˜åœ¨
        _, err := sessionStore.Get(c.Request.Context(), sessionID)
        if err != nil {
            if errors.Is(err, errors.ErrSessionNotFound) {
                c.JSON(http.StatusNotFound, gin.H{
                    "error": gin.H{
                        "code":    "SESSION_NOT_FOUND",
                        "message": "ä¼šè¯ä¸å­˜åœ¨",
                    },
                })
                return
            }
            // ... å…¶ä»–é”™è¯¯å¤„ç†
        }

        // è½¯åˆ é™¤
        if err := sessionStore.Delete(c.Request.Context(), sessionID); err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{
                "error": gin.H{
                    "code":    "INTERNAL_ERROR",
                    "message": "åˆ é™¤ä¼šè¯å¤±è´¥",
                },
            })
            return
        }

        // è¿”å› 204 No Content
        c.Status(http.StatusNoContent)
    }
}
```

**3. è½¯åˆ é™¤å®ç°**

ç¡®ä¿ Redis Store å®ç°è½¯åˆ é™¤ï¼š

```go
// internal/store/redis/session.go

// Delete åˆ é™¤ä¼šè¯ï¼ˆè½¯åˆ é™¤ï¼‰
func (s *RedisSessionStore) Delete(ctx context.Context, id string) error {
    // è®¾ç½® deleted_at å­—æ®µ
    now := time.Now().Format(time.RFC3339)
    return s.client.HSet(ctx, fmt.Sprintf("session:%s", id), "deleted_at", now).Err()
}
```

#### æµ‹è¯•è¦æ±‚

- [ ] æµ‹è¯•åˆ é™¤æˆåŠŸè¿”å› 204
- [ ] æµ‹è¯•åˆ é™¤ä¸å­˜åœ¨çš„ä¼šè¯è¿”å› 404
- [ ] æµ‹è¯•è½¯åˆ é™¤åä¸å†å‡ºç°åœ¨åˆ—è¡¨ä¸­
- [ ] æµ‹è¯•é‡å¤åˆ é™¤

---

## æµ‹è¯•ç­–ç•¥æ€»è§ˆ

### æµ‹è¯•è¦†ç›–ç‡è¦æ±‚

éµå¾ª `doc/è§„èŒƒ.md` çš„æµ‹è¯•è¦æ±‚ï¼š
- æ ¸å¿ƒä¸šåŠ¡é€»è¾‘æµ‹è¯•è¦†ç›–ç‡ 80% ä»¥ä¸Š
- ä½¿ç”¨æ¥å£å’Œ Mock é¿å…ä¾èµ–å…·ä½“å®ç°
- æµ‹è¯•åº”è¯¥æ˜¯ç‹¬ç«‹çš„ï¼Œä¸ä¾èµ–æ‰§è¡Œé¡ºåº
- **æµ‹è¯•å¿…é¡»åœ¨ tests/ ç›®å½•ä¸‹**

### æµ‹è¯•ç±»å‹

**1. å•å…ƒæµ‹è¯•**

- ä½ç½®ï¼š`tests/unit/api/`
- ç›®æ ‡ï¼šæµ‹è¯•å•ä¸ª Handler å’Œä¸­é—´ä»¶
- ç­–ç•¥ï¼šä½¿ç”¨ Mock éš”ç¦» Redis ä¾èµ–

**2. HTTP é›†æˆæµ‹è¯•**

- ä½ç½®ï¼š`tests/integration/api/`
- ç›®æ ‡ï¼šæµ‹è¯• HTTP æ¥å£
- ç­–ç•¥ï¼šä½¿ç”¨ `httptest` åŒ…ï¼ŒçœŸå® Redisï¼ˆtestcontainersï¼‰

**3. é»‘ç›’æµ‹è¯•**

- ä½ç½®ï¼š`tests/e2e/api/`
- ç›®æ ‡ï¼šä»ä½¿ç”¨è€…è§’åº¦æµ‹è¯•
- ç­–ç•¥ï¼šå¯åŠ¨çœŸå®æœåŠ¡å™¨ï¼Œä½¿ç”¨ curl/http.Client æµ‹è¯•

### HTTP æµ‹è¯•æ¡†æ¶

```go
// tests/testutil/server.go

// Package testutil æä¾›æµ‹è¯•å·¥å…·
package testutil

import (
    "testing"
    "github.com/gin-gonic/gin"
    "dnd-client/internal/store"
)

// SetupTestRouter è®¾ç½®æµ‹è¯•è·¯ç”±
func SetupTestRouter(sessionStore store.SessionStore) *gin.Engine {
    gin.SetMode(gin.TestMode)
    router := gin.New()

    api := router.Group("/api")
    {
        sessions := api.Group("/sessions")
        {
            sessions.POST("", handler.CreateSession(sessionStore))
            sessions.GET("", handler.ListSessions(sessionStore))
            sessions.GET("/:id", handler.GetSession(sessionStore))
            sessions.PATCH("/:id", handler.UpdateSession(sessionStore))
            sessions.DELETE("/:id", handler.DeleteSession(sessionStore))
        }
    }

    return router
}
```

---

## å¼€å‘æ­¥éª¤å»ºè®®

### Step 1: HTTP æœåŠ¡å™¨åŸºç¡€ï¼ˆéœ€æ±‚ 3.1ï¼‰

1. æ‰©å±• `pkg/config/config.go`ï¼Œæ·»åŠ  HTTP é…ç½®
2. å®ç° `internal/api/server.go`
3. å®ç°ä¸­é—´ä»¶ï¼ˆlogging, recovery, corsï¼‰
4. å®ç° `internal/api/router.go`
5. å®ç° `internal/cli/server.go` å‘½ä»¤
6. ç¼–å†™å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
7. æµ‹è¯•æœåŠ¡å™¨å¯åŠ¨å’Œå…³é—­

### Step 2: åˆ›å»ºä¼šè¯ APIï¼ˆéœ€æ±‚ 3.2ï¼‰

1. å®ç° `internal/api/handler/session.go` çš„ CreateSession
2. å®ç°å‚æ•°éªŒè¯
3. å®ç°é”™è¯¯å¤„ç†
4. ç¼–å†™ HTTP æµ‹è¯•
5. éªŒè¯å“åº”æ ¼å¼

### Step 3: è·å–ä¼šè¯è¯¦æƒ… APIï¼ˆéœ€æ±‚ 3.3ï¼‰

1. å®ç° GetSession Handler
2. å®ç° UUID éªŒè¯
3. å®ç°ä¼šè¯ä¸å­˜åœ¨é”™è¯¯å¤„ç†
4. ç¼–å†™ HTTP æµ‹è¯•

### Step 4: åˆ—å‡ºä¼šè¯ APIï¼ˆéœ€æ±‚ 3.4ï¼‰

1. å®ç° ListSessions Handler
2. å®ç°çŠ¶æ€è¿‡æ»¤
3. å®ç°æ’åºé€»è¾‘
4. ç¼–å†™ HTTP æµ‹è¯•

### Step 5: æ›´æ–°ä¼šè¯ APIï¼ˆéœ€æ±‚ 3.5ï¼‰

1. å®ç° UpdateSession Handler
2. å®ç°éƒ¨åˆ†æ›´æ–°é€»è¾‘
3. å®ç°å‚æ•°éªŒè¯
4. ç¼–å†™ HTTP æµ‹è¯•

### Step 6: åˆ é™¤ä¼šè¯ APIï¼ˆéœ€æ±‚ 3.6ï¼‰

1. å®ç° DeleteSession Handler
2. ç¡®è®¤è½¯åˆ é™¤å®ç°
3. ç¼–å†™ HTTP æµ‹è¯•
4. éªŒè¯åˆ é™¤åä¸å†å‡ºç°åœ¨åˆ—è¡¨ä¸­

### Step 7: å®Œå–„å’Œæµ‹è¯•

1. å®Œå–„é”™è¯¯å¤„ç†
2. æ·»åŠ è¯·æ±‚æ—¥å¿—
3. æ·»åŠ æ€§èƒ½ç›‘æ§
4. ç¼–å†™é»‘ç›’æµ‹è¯•
5. å®Œå–„æ–‡æ¡£

---

## éªŒæ”¶æ£€æŸ¥æ¸…å•

### ä»£ç è´¨é‡

- [ ] æ‰€æœ‰ä»£ç ç¬¦åˆ `doc/è§„èŒƒ.md` è¦æ±‚
- [ ] ä½¿ç”¨ `gofmt` æ ¼å¼åŒ–
- [ ] ä½¿ç”¨ `go vet` æ£€æŸ¥
- [ ] ä½¿ç”¨ `golint` æ£€æŸ¥
- [ ] ä»£ç å®¡æŸ¥é€šè¿‡
- [ ] å¤ç”¨ä»»åŠ¡ä¸€çš„æ¨¡å‹å’Œ store

### ç›®å½•ç»“æ„

- [ ] API ä»£ç åœ¨ `internal/api/` ç›®å½•
- [ ] æµ‹è¯•æ–‡ä»¶åœ¨ `tests/` ç›®å½•
- [ ] äºŒè¿›åˆ¶è¾“å‡ºåˆ° `bin/` ç›®å½•

### ä¾èµ–å…³ç³»

- [ ] ä¾èµ–æ–¹å‘æ­£ç¡®ï¼šhandler â†’ store â†’ models
- [ ] models ä¸ä¾èµ–ä»»ä½•å…¶ä»–åŒ…
- [ ] å•å‘ä¾èµ–ï¼Œæ— å¾ªç¯ä¾èµ–

### åŠŸèƒ½å®Œæ•´æ€§

- [ ] HTTP æœåŠ¡å™¨æ­£å¸¸å¯åŠ¨
- [ ] åˆ›å»ºä¼šè¯ API æ­£å¸¸
- [ ] è·å–ä¼šè¯è¯¦æƒ… API æ­£å¸¸
- [ ] åˆ—å‡ºä¼šè¯ API æ­£å¸¸
- [ ] æ›´æ–°ä¼šè¯ API æ­£å¸¸
- [ ] åˆ é™¤ä¼šè¯ API æ­£å¸¸
- [ ] é”™è¯¯å¤„ç†æ­£ç¡®

### HTTP è§„èŒƒ

- [ ] çŠ¶æ€ç æ­£ç¡®ï¼ˆ201, 200, 204, 400, 404, 500ï¼‰
- [ ] å“åº”æ ¼å¼ç¬¦åˆè§„èŒƒ
- [ ] é”™è¯¯å“åº”æ ¼å¼ç»Ÿä¸€
- [ ] æ—¶é—´æ ¼å¼ç»Ÿä¸€ä½¿ç”¨ RFC3339
- [ ] å‚æ•°éªŒè¯å®Œæ•´

### ä¸­é—´ä»¶

- [ ] æ—¥å¿—ä¸­é—´ä»¶æ­£å¸¸å·¥ä½œ
- [ ] æ¢å¤ä¸­é—´ä»¶èƒ½æ•è· panic
- [ ] CORS ä¸­é—´ä»¶æ­£ç¡®è®¾ç½®å¤´
- [ ] ä¼˜é›…å…³é—­æ­£å¸¸å·¥ä½œ

### æµ‹è¯•å®Œæ•´æ€§

- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 80%
- [ ] HTTP é›†æˆæµ‹è¯•å…¨éƒ¨é€šè¿‡
- [ ] é»‘ç›’æµ‹è¯•å…¨éƒ¨é€šè¿‡
- [ ] æµ‹è¯•å¯ä»¥ç‹¬ç«‹è¿è¡Œ

### æ€§èƒ½è¦æ±‚

- [ ] API å“åº”æ—¶é—´ < 10msï¼ˆä¸å« Redisï¼‰
- [ ] å¹¶å‘æ”¯æŒ 100 req/s
- [ ] å†…å­˜ä½¿ç”¨åˆç†

### æ–‡æ¡£å®Œæ•´æ€§

- [ ] `doc/development_progress.md` æ›´æ–°
- [ ] ä»£ç æ³¨é‡Šå®Œæ•´
- [ ] API æ–‡æ¡£å®Œæ•´

---

## ä¾èµ–æ¸…å•

### Go ä¾èµ–

åœ¨ä»»åŠ¡ä¸€çš„åŸºç¡€ä¸Šæ–°å¢ï¼š

```go
require (
    github.com/gin-gonic/gin v1.10.0  // HTTP æ¡†æ¶
    github.com/google/uuid v1.6.0     // UUID ç”Ÿæˆï¼ˆä»»åŠ¡ä¸€å·²æœ‰ï¼‰
)
```

### å¤–éƒ¨ä¾èµ–

- Redis 7.0+ï¼ˆä»»åŠ¡ä¸€å·²æœ‰ï¼‰

### å¼€å‘ä¾èµ–

```go
require (
    github.com/stretchr/testify v1.9.0  // æµ‹è¯•æ¡†æ¶
)
```

---

## é£é™©å’Œæ³¨æ„äº‹é¡¹

### å…³é”®è§„èŒƒçº¦æŸ âš ï¸

1. **æµ‹è¯•æ–‡ä»¶ä½ç½®**
   - âŒ **ç¦æ­¢**ï¼šæµ‹è¯•æ–‡ä»¶æ•£è½åœ¨å„åŒ…ä¸­
   - âœ… **å¿…é¡»**ï¼šæ‰€æœ‰æµ‹è¯•åœ¨ `tests/` ç›®å½•
   - åŸå› ï¼šè§„èŒƒè¦æ±‚ `tests/ - æµ‹è¯•æ–‡ä»¶`

2. **ä¾èµ–æ–¹å‘**
   - âŒ **ç¦æ­¢**ï¼šmodels ä¾èµ–å…¶ä»–åŒ…
   - âŒ **ç¦æ­¢**ï¼šhandler ä¾èµ–å…·ä½“çš„ store å®ç°ï¼ˆåº”è¯¥ä¾èµ–æ¥å£ï¼‰
   - âœ… **å¿…é¡»**ï¼šhandler â†’ store interface â†’ store impl â†’ models
   - åŸå› ï¼šè§„èŒƒè¦æ±‚å•å‘ä¾èµ–

3. **äºŒè¿›åˆ¶è¾“å‡ºä½ç½®**
   - âŒ **ç¦æ­¢**ï¼šè¾“å‡ºåˆ°å…¶ä»–ä½ç½®
   - âœ… **å¿…é¡»**ï¼šè¾“å‡ºåˆ° `bin/` ç›®å½•
   - åŸå› ï¼šè§„èŒƒè¦æ±‚ `bin/ - äºŒè¿›åˆ¶è¾“å‡ºä»¶ä½ç½®`

4. **é”™è¯¯å¤„ç†**
   - âŒ **ç¦æ­¢**ï¼šè®°å½•æ—¥å¿—åè¿”å› nil
   - âœ… **å¿…é¡»**ï¼šé”™è¯¯åº”è¯¥è¿”å›ç»™è°ƒç”¨æ–¹
   - åŸå› ï¼šè§„èŒƒè¦æ±‚"é”™è¯¯åº”è¯¥è¿”å›ï¼Œä¸æ˜¯è®°å½•æ—¥å¿—åè¿”å› nil"

### é£é™©

1. **å¹¶å‘å®‰å…¨é—®é¢˜**
   - ç¼“è§£ï¼šä½¿ç”¨ context æ§åˆ¶ Goroutine ç”Ÿå‘½å‘¨æœŸ
   - æµ‹è¯•ï¼šå¹¶å‘æµ‹è¯•

2. **Redis è¿æ¥å¤±è´¥**
   - ç¼“è§£ï¼šæä¾›è¯¦ç»†çš„é”™è¯¯æç¤º
   - é™çº§ï¼šè¿”å› 503 çŠ¶æ€ç 

3. **å‚æ•°éªŒè¯ä¸å®Œæ•´**
   - ç¼“è§£ï¼šä½¿ç”¨ Gin binding éªŒè¯
   - è¡¥å……ï¼šè‡ªå®šä¹‰ä¸šåŠ¡é€»è¾‘éªŒè¯

### æ³¨æ„äº‹é¡¹

1. ä¸¥æ ¼éµå¾ª `doc/è§„èŒƒ.md` çš„æ‰€æœ‰è¦æ±‚
2. å¤ç”¨ä»»åŠ¡ä¸€çš„ store å±‚å’Œæ¨¡å‹å±‚
3. ä¸ä¿®æ”¹ä»»åŠ¡ä¸€çš„ä»£ç 
4. ä½¿ç”¨ä¾èµ–æ³¨å…¥ï¼Œé¿å…å…¨å±€å˜é‡
5. ä¿æŒä»£ç ç®€æ´ã€æ¸…æ™°ã€æ˜“è¯»
6. ä¼˜å…ˆé€‰æ‹©ç®€å•ç›´æ¥çš„å®ç°
7. ä¿æŒä»£ç é£æ ¼ä¸€è‡´
8. å°æ­¥æäº¤ï¼Œé¢‘ç¹é›†æˆ
9. æ³¨æ„æ—¶é—´æ ¼å¼ç»Ÿä¸€ä½¿ç”¨ RFC3339
10. æ³¨æ„ UUID æ ¼å¼éªŒè¯
11. é”™è¯¯å“åº”æ ¼å¼ç»Ÿä¸€

---

## ä¸ä»»åŠ¡ä¸€çš„å¯¹æ¥

### Store å±‚å®Œå…¨å¤ç”¨

ä»»åŠ¡ä¸‰å®Œå…¨å¤ç”¨ä»»åŠ¡ä¸€çš„ store å±‚ï¼š

```go
// ä»»åŠ¡ä¸€å·²å®šä¹‰
// internal/store/redis/session.go
type RedisSessionStore struct { ... }
func (s *RedisSessionStore) Create(ctx context.Context, session *models.Session) error
func (s *RedisSessionStore) Get(ctx context.Context, id string) (*models.Session, error)
func (s *RedisSessionStore) List(ctx context.Context) ([]*models.Session, error)
func (s *RedisSessionStore) Update(ctx context.Context, session *models.Session) error
func (s *RedisSessionStore) Delete(ctx context.Context, id string) error

// ä»»åŠ¡ä¸‰ç›´æ¥ä½¿ç”¨ï¼Œæ— éœ€ä¿®æ”¹
```

### æ¨¡å‹å®Œå…¨å¤ç”¨

ä»»åŠ¡ä¸‰å®Œå…¨å¤ç”¨ä»»åŠ¡ä¸€çš„æ¨¡å‹å®šä¹‰ï¼š

```go
// ä»»åŠ¡ä¸€å·²å®šä¹‰
// internal/models/session.go
type Session struct {
    ID           string
    Name         string
    // ...
}

// ä»»åŠ¡ä¸‰ç›´æ¥ä½¿ç”¨ï¼Œæ— éœ€ä¿®æ”¹
```

### é…ç½®æ‰©å±•

åœ¨ä»»åŠ¡ä¸€çš„é…ç½®åŸºç¡€ä¸Šæ·»åŠ  HTTP é…ç½®ï¼š

```go
// ä»»åŠ¡ä¸€çš„ Config
type Config struct {
    Redis RedisConfig
    // ä»»åŠ¡ä¸‰æ·»åŠ 
    HTTP  HTTPConfig
    Log   LogConfig
}
```

---

## æ€§èƒ½åŸºå‡†

### API æ€§èƒ½

| æ“ä½œ | é¢„æœŸå“åº”æ—¶é—´ | è¯´æ˜ |
|------|-------------|------|
| åˆ›å»ºä¼šè¯ | < 10ms | ä¸å« Redis æ“ä½œ |
| è·å–ä¼šè¯è¯¦æƒ… | < 5ms | å« Redis æŸ¥è¯¢ |
| åˆ—å‡ºä¼šè¯ | < 10ms | å« Redis æŸ¥è¯¢ |
| æ›´æ–°ä¼šè¯ | < 10ms | å« Redis æ“ä½œ |
| åˆ é™¤ä¼šè¯ | < 5ms | å« Redis æ“ä½œ |

### å¹¶å‘æ€§èƒ½

- æ”¯æŒ 100 req/s
- P95 å“åº”æ—¶é—´ < 20ms
- P99 å“åº”æ—¶é—´ < 50ms

---

## å‚è€ƒèµ„æ–™

- `doc/è§„èŒƒ.md` - **ä»£ç è§„èŒƒï¼ˆæœ€é‡è¦ï¼‰**
- `doc/DND_MCP_Clientè¯¦ç»†è®¾è®¡.md` - è¯¦ç»†è®¾è®¡
- `doc/DND_MCP_Client_å¼€å‘è®¡åˆ’.md` - å¼€å‘è®¡åˆ’
- `doc/å¼€å‘ä»»åŠ¡ä¸€.md` - ä»»åŠ¡ä¸€æ–‡æ¡£
- https://gin-gonic.com/docs/ - Gin æ–‡æ¡£
- https://pkg.go.dev/net/http/httptest - httptest æ–‡æ¡£

---

## é™„å½•ï¼šHTTP çŠ¶æ€ç è§„èŒƒ

### çŠ¶æ€ç ä½¿ç”¨è§„èŒƒ

| çŠ¶æ€ç  | ä½¿ç”¨åœºæ™¯ | ç¤ºä¾‹ |
|--------|---------|------|
| 200 OK | è¯·æ±‚æˆåŠŸ | è·å–ä¼šè¯æˆåŠŸ |
| 201 Created | èµ„æºåˆ›å»ºæˆåŠŸ | åˆ›å»ºä¼šè¯æˆåŠŸ |
| 204 No Content | åˆ é™¤æˆåŠŸ | åˆ é™¤ä¼šè¯æˆåŠŸ |
| 400 Bad Request | è¯·æ±‚å‚æ•°é”™è¯¯ | ç¼ºå°‘å¿…å¡«å­—æ®µ |
| 404 Not Found | èµ„æºä¸å­˜åœ¨ | ä¼šè¯ä¸å­˜åœ¨ |
| 500 Internal Server Error | æœåŠ¡å™¨é”™è¯¯ | æœªé¢„æœŸçš„é”™è¯¯ |
| 503 Service Unavailable | æœåŠ¡ä¸å¯ç”¨ | Redis è¿æ¥å¤±è´¥ |

### é”™è¯¯ç è§„èŒƒ

æ ¼å¼ï¼š`{SERVICE}_{ERROR_TYPE}`

ç¤ºä¾‹ï¼š
- `INVALID_REQUEST` - è¯·æ±‚å‚æ•°é”™è¯¯
- `INVALID_SESSION_ID` - ä¼šè¯IDæ ¼å¼é”™è¯¯
- `SESSION_NOT_FOUND` - ä¼šè¯ä¸å­˜åœ¨
- `INVALID_MAX_PLAYERS` - max_players å‚æ•°é”™è¯¯
- `REDIS_UNAVAILABLE` - Redis ä¸å¯ç”¨
- `INTERNAL_ERROR` - å†…éƒ¨é”™è¯¯

---

## é™„å½•ï¼šå®Œæ•´ç¤ºä¾‹

### å¯åŠ¨æœåŠ¡å™¨

```bash
# æ„å»ºé¡¹ç›®
./scripts/build.sh

# å¯åŠ¨æœåŠ¡å™¨
./bin/dnd-client server start

# è¾“å‡ºç¤ºä¾‹
INFO HTTP æœåŠ¡å™¨å¯åŠ¨ addr=0.0.0.0:8080 timeout=30s
```

### æµ‹è¯• API

```bash
# åˆ›å»ºä¼šè¯
curl -X POST http://localhost:8080/api/sessions \
  -H "Content-Type: application/json" \
  -d '{
    "name": "æˆ‘çš„ç¬¬ä¸€ä¸ªæˆ˜å½¹",
    "creator_id": "user-123",
    "mcp_server_url": "http://localhost:9000",
    "max_players": 5
  }'

# å“åº”
{
  "id": "123e4567-e89b-12d3-a456-426614174000",
  "name": "æˆ‘çš„ç¬¬ä¸€ä¸ªæˆ˜å½¹",
  "creator_id": "user-123",
  "mcp_server_url": "http://localhost:9000",
  "websocket_key": "ws-abc-123",
  "max_players": 5,
  "settings": null,
  "created_at": "2025-02-03T10:00:00Z",
  "updated_at": "2025-02-03T10:00:00Z",
  "status": "active"
}

# è·å–ä¼šè¯åˆ—è¡¨
curl http://localhost:8080/api/sessions

# è·å–ä¼šè¯è¯¦æƒ…
curl http://localhost:8080/api/sessions/123e4567-e89b-12d3-a456-426614174000

# æ›´æ–°ä¼šè¯
curl -X PATCH http://localhost:8080/api/sessions/123e4567-e89b-12d3-a456-426614174000 \
  -H "Content-Type: application/json" \
  -d '{"name": "æ›´æ–°çš„ä¼šè¯åç§°"}'

# åˆ é™¤ä¼šè¯
curl -X DELETE http://localhost:8080/api/sessions/123e4567-e89b-12d3-a456-426614174000
```
