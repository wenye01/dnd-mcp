# DND MCP Client - ä»»åŠ¡ä¸ƒå¼€å‘è®¡åˆ’

## MCP Server é›†æˆ

### æ–‡æ¡£ä¿¡æ¯

- **ä»»åŠ¡ç¼–å·**: Task-7
- **ä»»åŠ¡åç§°**: MCP Server é›†æˆ
- **å‰ç½®ä»»åŠ¡**: Task-5(WebSocket)ã€Task-6(LLM é›†æˆ)
- **åŸºäºæ–‡æ¡£**: DND_MCP_Clientè¯¦ç»†è®¾è®¡.mdã€DND_MCP_Client_å¼€å‘è®¡åˆ’.md
- **å¿…é¡»éµå®ˆ**: doc/è§„èŒƒ.md

---

## ä»»åŠ¡æ¦‚è¿°

### ç›®æ ‡

åœ¨ä»»åŠ¡äº”ã€ä»»åŠ¡å…­çš„åŸºç¡€ä¸Š,é›†æˆ MCP Server,å®ç°å·¥å…·è°ƒç”¨å’Œäº‹ä»¶è®¢é˜…åŠŸèƒ½ã€‚å½“ LLM è¿”å› tool_calls æ—¶,é€šè¿‡ MCP Client è°ƒç”¨ MCP Server çš„å·¥å…·,å¹¶å°†ç»“æœè¿”å›ç»™ LLM ç»§ç»­å¯¹è¯ã€‚

### åŸºäºå‰ç½®ä»»åŠ¡çš„æˆæœ

**ä»»åŠ¡äº”å·²å®Œæˆ**:
- âœ… WebSocket Hub å’Œ Connection ç®¡ç†
- âœ… äº‹ä»¶å¹¿æ’­æœºåˆ¶
- âœ… Mock äº‹ä»¶ç”Ÿæˆå™¨

**ä»»åŠ¡å…­å·²å®Œæˆ**:
- âœ… LLM Client æ¥å£å’Œ OpenAI å®ç°
- âœ… tool_calls è§£æ
- âœ… å¯¹è¯ä¸Šä¸‹æ–‡æ„å»º
- âœ… é…ç½®é©±åŠ¨çš„ Provider åˆ‡æ¢

### ä»»åŠ¡ä¸ƒæ–°å¢åŠŸèƒ½

- ğŸ”Œ MCP Client æ¥å£å’Œå®ç°
- ğŸ“ MCP Server æ¡æ‰‹å’Œåˆå§‹åŒ–
- ğŸ”§ å·¥å…·è°ƒç”¨æ‰§è¡Œ(Call Tool)
- ğŸ“¡ äº‹ä»¶è®¢é˜…å’Œç›‘å¬
- ğŸ”„ äº‹ä»¶è½¬æ¢ä¸º WebSocket æ¨é€
- ğŸ­ Mock MCP Server(ç”¨äºæµ‹è¯•)

### æ¶æ„è¯´æ˜

**âš ï¸ é‡è¦ï¼šç»§ç»­é‡‡ç”¨ç®€åŒ–æ¶æ„**

ä¸ä»»åŠ¡äº”ã€ä»»åŠ¡å…­ä¿æŒä¸€è‡´,ä»»åŠ¡ä¸ƒç»§ç»­é‡‡ç”¨ç®€åŒ–æ¶æ„:

```
Handler (message.go)
  â†“ ç›´æ¥è°ƒç”¨
LLMClient â†’ è¿”å› tool_calls
  â†“
Handler.handleToolCalls()
  â†“ ç›´æ¥è°ƒç”¨
MCPClient (æ‰§è¡Œå·¥å…·)
  â†“
è¿”å›å·¥å…·ç»“æœ â†’ ç»§ç»­è°ƒç”¨ LLM â†’ ç”Ÿæˆæœ€ç»ˆå“åº”
```

**ä¸æ·»åŠ é¢å¤–å±‚æ¬¡**:
- âŒ ä¸æ·»åŠ  ToolCoordinator Service å±‚
- âŒ ä¸æ·»åŠ å¤æ‚çš„ç¼–æ’å™¨
- âœ… Handler ç›´æ¥è°ƒç”¨ MCPClient

**ç†ç”±**:
- å·¥å…·è°ƒç”¨é€»è¾‘ç›¸å¯¹æ¸…æ™°(LLM â†’ MCP â†’ LLM)
- å¿«é€Ÿå®ç° MCP é›†æˆåŠŸèƒ½
- ä¿æŒä»£ç ç®€æ´,æ˜“äºç†è§£å’Œè°ƒè¯•

---

## æ ¸å¿ƒåŠŸèƒ½

### 1. MCP Client åˆå§‹åŒ–å’Œæ¡æ‰‹ (éœ€æ±‚ 7.1)

#### å®ç°å†…å®¹

**MCP Client æ¥å£** (`internal/mcp/client.go`)

```go
// Package mcp æä¾› MCP Client æ¥å£å’Œå®ç°
package mcp

import (
    "context"
    "time"
)

// MCPClient MCP å®¢æˆ·ç«¯æ¥å£
type MCPClient interface {
    // Initialize åˆå§‹åŒ– MCP è¿æ¥(æ¡æ‰‹)
    Initialize(ctx context.Context, sessionID, serverURL string) error

    // CallTool è°ƒç”¨ MCP Server å·¥å…·
    CallTool(ctx context.Context, sessionID string, toolName string, arguments map[string]interface{}) (map[string]interface{}, error)

    // SubscribeEvents è®¢é˜… MCP Server äº‹ä»¶
    SubscribeEvents(ctx context.Context, sessionID string, eventTypes []string) (<-chan Event, error)

    // Close å…³é—­ MCP è¿æ¥
    Close(ctx context.Context) error
}

// Event MCP Server äº‹ä»¶
type Event struct {
    Type      string                 `json:"type"`       // state_changed, combat_updated, etc.
    SessionID string                 `json:"session_id"`
    Data      map[string]interface{} `json:"data"`
    Timestamp time.Time              `json:"timestamp"`
}
```

**HTTP MCP Client å®ç°** (`internal/mcp/http.go`)

```go
// Package mcp æä¾› HTTP MCP Client å®ç°
package mcp

import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "time"
)

// HTTPClient HTTP MCP å®¢æˆ·ç«¯
type HTTPClient struct {
    baseURL    string
    httpClient *http.Client
    sessionID  string
}

// NewHTTPClient åˆ›å»º HTTP MCP å®¢æˆ·ç«¯
func NewHTTPClient(baseURL string) *HTTPClient {
    return &HTTPClient{
        baseURL: baseURL,
        httpClient: &http.Client{
            Timeout: 30 * time.Second,
        },
    }
}

// Initialize åˆå§‹åŒ– MCP è¿æ¥
func (c *HTTPClient) Initialize(ctx context.Context, sessionID, serverURL string) error {
    c.sessionID = sessionID
    c.baseURL = serverURL

    // è°ƒç”¨ MCP Server çš„ initialize æ¥å£
    req := map[string]interface{}{
        "session_id": sessionID,
        "capabilities": []string{"tools", "events"},
    }

    body, err := json.Marshal(req)
    if err != nil {
        return fmt.Errorf("åºåˆ—åŒ–è¯·æ±‚å¤±è´¥: %w", err)
    }

    httpReq, err := http.NewRequestWithContext(ctx, "POST",
        c.baseURL+"/initialize",
        bytes.NewReader(body))
    if err != nil {
        return fmt.Errorf("åˆ›å»º HTTP è¯·æ±‚å¤±è´¥: %w", err)
    }

    httpReq.Header.Set("Content-Type", "application/json")

    resp, err := c.httpClient.Do(httpReq)
    if err != nil {
        return fmt.Errorf("å‘é€åˆå§‹åŒ–è¯·æ±‚å¤±è´¥: %w", err)
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        respBody, _ := io.ReadAll(resp.Body)
        return fmt.Errorf("åˆå§‹åŒ–å¤±è´¥ (status %d): %s", resp.StatusCode, string(respBody))
    }

    return nil
}

// CallTool è°ƒç”¨å·¥å…·
func (c *HTTPClient) CallTool(ctx context.Context, sessionID string, toolName string, arguments map[string]interface{}) (map[string]interface{}, error) {
    req := map[string]interface{}{
        "session_id": sessionID,
        "tool":       toolName,
        "arguments":  arguments,
    }

    body, err := json.Marshal(req)
    if err != nil {
        return nil, fmt.Errorf("åºåˆ—åŒ–è¯·æ±‚å¤±è´¥: %w", err)
    }

    httpReq, err := http.NewRequestWithContext(ctx, "POST",
        c.baseURL+"/tools/call",
        bytes.NewReader(body))
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º HTTP è¯·æ±‚å¤±è´¥: %w", err)
    }

    httpReq.Header.Set("Content-Type", "application/json")

    resp, err := c.httpClient.Do(httpReq)
    if err != nil {
        return nil, fmt.Errorf("è°ƒç”¨å·¥å…·å¤±è´¥: %w", err)
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        respBody, _ := io.ReadAll(resp.Body)
        return nil, fmt.Errorf("å·¥å…·è°ƒç”¨å¤±è´¥ (status %d): %s", resp.StatusCode, string(respBody))
    }

    var result map[string]interface{}
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return nil, fmt.Errorf("è§£æå“åº”å¤±è´¥: %w", err)
    }

    return result, nil
}

// SubscribeEvents è®¢é˜…äº‹ä»¶(HTTP è½®è¯¢æ¨¡æ‹Ÿ)
func (c *HTTPClient) SubscribeEvents(ctx context.Context, sessionID string, eventTypes []string) (<-chan Event, error) {
    eventChan := make(chan Event, 10)

    go func() {
        defer close(eventChan)

        ticker := time.NewTicker(2 * time.Second)
        defer ticker.Stop()

        for {
            select {
            case <-ctx.Done():
                return
            case <-ticker.C:
                // è½®è¯¢è·å–äº‹ä»¶
                events, err := c.pollEvents(ctx, sessionID, eventTypes)
                if err != nil {
                    continue
                }

                for _, event := range events {
                    select {
                    case eventChan <- event:
                    case <-ctx.Done():
                        return
                    }
                }
            }
        }
    }()

    return eventChan, nil
}

// pollEvents è½®è¯¢äº‹ä»¶
func (c *HTTPClient) pollEvents(ctx context.Context, sessionID string, eventTypes []string) ([]Event, error) {
    // æ„å»ºæŸ¥è¯¢å‚æ•°
    req, err := http.NewRequestWithContext(ctx, "GET",
        c.baseURL+"/events?session_id="+sessionID, nil)
    if err != nil {
        return nil, err
    }

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("è·å–äº‹ä»¶å¤±è´¥: status %d", resp.StatusCode)
    }

    var events []Event
    if err := json.NewDecoder(resp.Body).Decode(&events); err != nil {
        return nil, err
    }

    return events, nil
}

// Close å…³é—­è¿æ¥
func (c *HTTPClient) Close(ctx context.Context) error {
    // HTTP æ— çŠ¶æ€,æ— éœ€å…³é—­
    return nil
}
```

**MCP Client å·¥å‚** (`internal/mcp/client.go`)

```go
// NewClient åˆ›å»º MCP å®¢æˆ·ç«¯
func NewClient(serverURL string) (MCPClient, error) {
    if serverURL == "mock://" {
        return NewMockClient(), nil
    }

    return NewHTTPClient(serverURL), nil
}
```

**é…ç½®æ‰©å±•** (`pkg/config/config.go`)

```go
// Config åº”ç”¨é…ç½®
type Config struct {
    // ... ç°æœ‰å­—æ®µ ...
    MCP MCPConfig `mapstructure:"mcp"` // æ–°å¢
}

// MCPConfig MCP é…ç½®
type MCPConfig struct {
    ServerURL string `mapstructure:"server_url" env:"MCP_SERVER_URL" default:"mock://"` // mock:// or http://...
    Timeout   int    `mapstructure:"timeout" env:"MCP_TIMEOUT" default:"30"`             // seconds
}

// Load åŠ è½½é…ç½®
func Load() (*Config, error) {
    cfg := &Config{
        // ... ç°æœ‰é…ç½® ...
        MCP: MCPConfig{
            ServerURL: getEnv("MCP_SERVER_URL", "mock://"),
            Timeout:   getEnvInt("MCP_TIMEOUT", 30),
        },
    }

    return cfg, nil
}
```

---

### 2. è°ƒç”¨ MCP Server å·¥å…· (éœ€æ±‚ 7.2)

#### å®ç°å†…å®¹

**Handler æ‰©å±• - å®Œæˆå·¥å…·è°ƒç”¨æµç¨‹** (`internal/api/handler/message.go` ä¿®æ”¹)

```go
// MessageHandler æ¶ˆæ¯å¤„ç†å™¨
type MessageHandler struct {
    messageStore store.MessageStore
    sessionStore store.SessionStore
    llmClient    llm.LLMClient
    mcpClient    mcp.MCPClient // æ–°å¢
    wsHub        *ws.Hub
}

// NewMessageHandler åˆ›å»ºæ¶ˆæ¯å¤„ç†å™¨
func NewMessageHandler(
    messageStore store.MessageStore,
    sessionStore store.SessionStore,
    llmClient llm.LLMClient,
    mcpClient mcp.MCPClient, // æ–°å¢
    wsHub *ws.Hub,
) *MessageHandler {
    return &MessageHandler{
        messageStore: messageStore,
        sessionStore: sessionStore,
        llmClient:    llmClient,
        mcpClient:    mcpClient, // æ–°å¢
        wsHub:        wsHub,
    }
}

// SendMessage å‘é€æ¶ˆæ¯å¹¶è·å– AI å“åº”
func (h *MessageHandler) SendMessage(c *gin.Context) {
    ctx := c.Request.Context()
    sessionID := c.Param("sessionId")

    // ... ç°æœ‰ä»£ç : éªŒè¯ä¼šè¯ã€ä¿å­˜ç”¨æˆ·æ¶ˆæ¯ã€æ„å»ºä¸Šä¸‹æ–‡ ...

    // è°ƒç”¨ LLM
    llmResp, err := h.llmClient.Chat(ctx, llmReq)
    if err != nil {
        // é”™è¯¯å¤„ç†
        return
    }

    choice := llmResp.Choices[0]

    // åˆ¤æ–­æ˜¯å¦æœ‰ tool_calls
    if choice.FinishReason == "tool_calls" && len(choice.Message.ToolCalls) > 0 {
        // ğŸ†• æ‰§è¡Œå·¥å…·è°ƒç”¨
        return h.handleToolCalls(c, sessionID, choice.Message.ToolCalls)
    }

    // ... ç°æœ‰ä»£ç : ä¿å­˜åŠ©æ‰‹æ¶ˆæ¯ã€è¿”å›å“åº” ...
}

// handleToolCalls å¤„ç†å·¥å…·è°ƒç”¨
func (h *MessageHandler) handleToolCalls(c *gin.Context, sessionID string, toolCalls []llm.ToolCall) {
    ctx := c.Request.Context()

    // 1. ä¿å­˜ assistant æ¶ˆæ¯(åŒ…å« tool_calls)
    assistantMsg := &models.Message{
        ID:        uuid.New().String(),
        SessionID: sessionID,
        Role:      "assistant",
        Content:   "",
        ToolCalls: convertLLMToolCalls(toolCalls),
        CreatedAt: time.Now(),
    }

    if err := h.messageStore.Create(ctx, assistantMsg); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "ä¿å­˜å·¥å…·è°ƒç”¨æ¶ˆæ¯å¤±è´¥"})
        return
    }

    // 2. ğŸ†• æ‰§è¡Œæ‰€æœ‰å·¥å…·è°ƒç”¨
    toolResults := make([]map[string]interface{}, len(toolCalls))
    for i, toolCall := range toolCalls {
        // è§£æ arguments
        var args map[string]interface{}
        json.Unmarshal([]byte(toolCall.Function.Arguments), &args)

        // è°ƒç”¨ MCP Server
        result, err := h.mcpClient.CallTool(ctx, sessionID, toolCall.Function.Name, args)
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{
                "error": fmt.Sprintf("å·¥å…·è°ƒç”¨å¤±è´¥: %s", err.Error()),
            })
            return
        }

        toolResults[i] = result
    }

    // 3. ğŸ†• ä¿å­˜ tool å“åº”æ¶ˆæ¯
    for i, toolCall := range toolCalls {
        toolMsg := &models.Message{
            ID:        uuid.New().String(),
            SessionID: sessionID,
            Role:      "tool",
            Content:   fmt.Sprintf("å·¥å…· %s æ‰§è¡Œç»“æœ: %+v", toolCall.Function.Name, toolResults[i]),
            CreatedAt: time.Now(),
        }

        if err := h.messageStore.Create(ctx, toolMsg); err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "ä¿å­˜å·¥å…·å“åº”å¤±è´¥"})
            return
        }
    }

    // 4. ğŸ†• ç»§ç»­è°ƒç”¨ LLM(ä¼ é€’å·¥å…·ç»“æœ)
    // é‡æ–°æ„å»ºä¸Šä¸‹æ–‡(åŒ…å«å·¥å…·è°ƒç”¨å’Œç»“æœ)
    followupReq := &llm.ChatRequest{
        Model: "gpt-4",
        Messages:    buildFollowupMessages(sessionID, toolCalls, toolResults),
        Temperature: 0.7,
    }

    followupResp, err := h.llmClient.Chat(ctx, followupReq)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "LLM åç»­è°ƒç”¨å¤±è´¥"})
        return
    }

    // 5. ä¿å­˜æœ€ç»ˆåŠ©æ‰‹å“åº”
    finalMsg := &models.Message{
        ID:        uuid.New().String(),
        SessionID: sessionID,
        Role:      followupResp.Choices[0].Message.Role,
        Content:   followupResp.Choices[0].Message.Content,
        CreatedAt: time.Now(),
    }

    if err := h.messageStore.Create(ctx, finalMsg); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "ä¿å­˜æœ€ç»ˆå“åº”å¤±è´¥"})
        return
    }

    // 6. è¿”å›æœ€ç»ˆå“åº”
    c.JSON(http.StatusOK, finalMsg)
}

// buildFollowupMessages æ„å»ºåç»­è¯·æ±‚çš„æ¶ˆæ¯
func buildFollowupMessages(sessionID string, toolCalls []llm.ToolCall, toolResults []map[string]interface{}) []llm.Message {
    messages := []llm.Message{}

    // æ·»åŠ  tool_calls æ¶ˆæ¯
    assistantToolMsg := llm.Message{
        Role:      "assistant",
        Content:   "",
        ToolCalls: toolCalls,
    }
    messages = append(messages, assistantToolMsg)

    // æ·»åŠ  tool å“åº”æ¶ˆæ¯
    for i, result := range toolResults {
        toolMsg := llm.Message{
            Role:       "tool",
            Content:    fmt.Sprintf("%+v", result),
            ToolCallID: toolCalls[i].ID,
        }
        messages = append(messages, toolMsg)
    }

    return messages
}
```

---

### 3. è®¢é˜… MCP Server äº‹ä»¶ (éœ€æ±‚ 7.3)

#### å®ç°å†…å®¹

**äº‹ä»¶ç›‘å¬å™¨** (`internal/mcp/listener.go`)

```go
// Package mcp æä¾› MCP äº‹ä»¶ç›‘å¬å™¨
package mcp

import (
    "context"
    "log"

    "github.com/dnd-mcp/client/internal/ws"
)

// EventListener äº‹ä»¶ç›‘å¬å™¨
type EventListener struct {
    mcpClient  MCPClient
    wsHub      *ws.Hub
    eventChan  <-chan Event
    sessionID  string
}

// NewEventListener åˆ›å»ºäº‹ä»¶ç›‘å¬å™¨
func NewEventListener(mcpClient MCPClient, wsHub *ws.Hub) *EventListener {
    return &EventListener{
        mcpClient: mcpClient,
        wsHub:     wsHub,
    }
}

// Start å¯åŠ¨äº‹ä»¶ç›‘å¬
func (l *EventListener) Start(ctx context.Context, sessionID string) error {
    l.sessionID = sessionID

    // è®¢é˜…æ‰€æœ‰äº‹ä»¶ç±»å‹
    eventTypes := []string{
        "state_changed",
        "combat_updated",
        "character_moved",
        "dice_rolled",
    }

    eventChan, err := l.mcpClient.SubscribeEvents(ctx, sessionID, eventTypes)
    if err != nil {
        return err
    }

    l.eventChan = eventChan

    // å¯åŠ¨äº‹ä»¶å¤„ç†å¾ªç¯
    go l.processEvents(ctx)

    return nil
}

// processEvents å¤„ç†äº‹ä»¶
func (l *EventListener) processEvents(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            return
        case event, ok := <-l.eventChan:
            if !ok {
                return
            }

            // è½¬æ¢ä¸º WebSocket äº‹ä»¶å¹¶å¹¿æ’­
            wsEvent := ws.Event{
                SessionID: l.sessionID,
                Type:      event.Type,
                Data:      event.Data,
            }

            l.wsHub.Broadcast <- wsEvent

            log.Printf("[MCP] äº‹ä»¶å·²å¹¿æ’­: type=%s, session=%s", event.Type, l.sessionID)
        }
    }
}
```

**é›†æˆåˆ°æœåŠ¡å™¨å¯åŠ¨** (`internal/cli/server.go` ä¿®æ”¹)

```go
// StartCommand å¯åŠ¨æœåŠ¡å™¨å‘½ä»¤
func StartCommand(cmd *cobra.Command, args []string) error {
    // åŠ è½½é…ç½®
    cfg, err := config.Load()
    if err != nil {
        return err
    }

    // åˆå§‹åŒ– LLM Client
    llmClient, err := llm.NewClient(&cfg.LLM)
    if err != nil {
        return err
    }

    // åˆå§‹åŒ– MCP Client
    mcpClient, err := mcp.NewClient(cfg.MCP.ServerURL)
    if err != nil {
        return err
    }

    // åˆå§‹åŒ– Redis
    redisClient := redis.NewClient(&redis.Options{
        Addr:     cfg.Redis.Host,
        Password: cfg.Redis.Password,
        DB:       cfg.Redis.DB,
    })

    sessionStore := redisstore.NewSessionStore(redisClient)
    messageStore := redisstore.NewMessageStore(redisClient)

    // åˆå§‹åŒ– WebSocket Hub
    wsHub := ws.NewHub()
    go wsHub.Run()

    // åˆ›å»º Handler
    sessionHandler := handler.NewSessionHandler(sessionStore)
    messageHandler := handler.NewMessageHandler(
        messageStore,
        sessionStore,
        llmClient,
        mcpClient, // æ–°å¢
        wsHub,
    )

    // é…ç½®è·¯ç”±
    r := api.Router(sessionStore, messageHandler, wsHub)

    // å¯åŠ¨ HTTP æœåŠ¡å™¨
    addr := fmt.Sprintf("%s:%d", cfg.HTTP.Host, cfg.HTTP.Port)
    server := &http.Server{
        Addr:    addr,
        Handler: r,
    }

    logrus.Infof("æœåŠ¡å™¨å¯åŠ¨åœ¨ http://%s", addr)
    return server.ListenAndServe()
}
```

---

### 4. äº‹ä»¶è½¬æ¢ä¸º WebSocket æ¨é€ (éœ€æ±‚ 7.4)

#### å®ç°å†…å®¹

è¿™ä¸ªåŠŸèƒ½å·²ç»åœ¨éœ€æ±‚ 7.3 ä¸­å®ç°:

1. MCP Server å‘é€äº‹ä»¶
2. EventListener æ¥æ”¶äº‹ä»¶
3. è½¬æ¢ä¸º ws.Event æ ¼å¼
4. é€šè¿‡ wsHub.Broadcast å¹¿æ’­åˆ°æ‰€æœ‰è®¢é˜…çš„ WebSocket è¿æ¥

**äº‹ä»¶æ ¼å¼ç¤ºä¾‹**:

```go
// MCP äº‹ä»¶
mcp.Event{
    Type:      "dice_rolled",
    SessionID: "session-123",
    Data: map[string]interface{}{
        "player_id": "player-123",
        "roll_type": "attack",
        "formula":   "1d20+5",
        "result":    18,
    },
    Timestamp: time.Now(),
}

// è½¬æ¢ä¸º WebSocket äº‹ä»¶
ws.Event{
    SessionID: "session-123",
    Type:      "dice_rolled",
    Data: map[string]interface{}{
        "player_id": "player-123",
        "roll_type": "attack",
        "formula":   "1d20+5",
        "result":    18,
    },
}

// WebSocket æ¨é€æ ¼å¼
{
  "type": "dice_rolled",
  "data": {
    "player_id": "player-123",
    "roll_type": "attack",
    "formula": "1d20+5",
    "result": 18
  }
}
```

---

### 5. Mock MCP Server (éœ€æ±‚ 7.5)

#### å®ç°å†…å®¹

**Mock MCP Client** (`internal/mcp/mock.go`)

```go
// Package mcp æä¾› Mock MCP å®ç°
package mcp

import (
    "context"
    "fmt"
    "time"
)

// MockClient Mock MCP å®¢æˆ·ç«¯
type MockClient struct{}

// NewMockClient åˆ›å»º Mock å®¢æˆ·ç«¯
func NewMockClient() *MockClient {
    return &MockClient{}
}

// Initialize åˆå§‹åŒ–
func (m *MockClient) Initialize(ctx context.Context, sessionID, serverURL string) error {
    return nil
}

// CallTool è°ƒç”¨å·¥å…·
func (m *MockClient) CallTool(ctx context.Context, sessionID string, toolName string, arguments map[string]interface{}) (map[string]interface{}, error) {
    // æ ¹æ®å·¥å…·åç§°è¿”å›æ¨¡æ‹Ÿç»“æœ
    switch toolName {
    case "roll_dice":
        return map[string]interface{}{
            "success": true,
            "result":  map[string]interface{}{
                "formula": arguments["formula"],
                "total":   18,
                "rolls":   []int{15},
                "modifier": 3,
            },
        }, nil

    case "resolve_attack":
        return map[string]interface{}{
            "success": true,
            "result": map[string]interface{}{
                "attacker": arguments["attacker"],
                "target":   arguments["target"],
                "hit":      true,
                "damage":   8,
            },
        }, nil

    default:
        return map[string]interface{}{
            "success": true,
            "message": fmt.Sprintf("å·¥å…· %s æ‰§è¡ŒæˆåŠŸ", toolName),
        }, nil
    }
}

// SubscribeEvents è®¢é˜…äº‹ä»¶
func (m *MockClient) SubscribeEvents(ctx context.Context, sessionID string, eventTypes []string) (<-chan Event, error) {
    eventChan := make(chan Event, 10)

    go func() {
        defer close(eventChan)

        ticker := time.NewTicker(10 * time.Second)
        defer ticker.Stop()

        for i := 0; ; i++ {
            select {
            case <-ctx.Done():
                return
            case <-ticker.C:
                // æ¨¡æ‹Ÿç”Ÿæˆäº‹ä»¶
                event := Event{
                    Type:      eventTypes[i%len(eventTypes)],
                    SessionID: sessionID,
                    Data: map[string]interface{}{
                        "mock": true,
                        "index": i,
                    },
                    Timestamp: time.Now(),
                }

                select {
                case eventChan <- event:
                case <-ctx.Done():
                    return
                }
            }
        }
    }()

    return eventChan, nil
}

// Close å…³é—­è¿æ¥
func (m *MockClient) Close(ctx context.Context) error {
    return nil
}
```

**é…ç½®é©±åŠ¨åˆ‡æ¢**:

```bash
# ä½¿ç”¨ Mock MCP Server
export MCP_SERVER_URL=mock://

# ä½¿ç”¨çœŸå® MCP Server
export MCP_SERVER_URL=http://localhost:9000
```

---

## æŠ€æœ¯äº®ç‚¹

1. **æ¥å£åŒ–è®¾è®¡**
   - å®šä¹‰ `MCPClient` æ¥å£
   - HTTP å’Œ Mock å®ç°åŒä¸€æ¥å£
   - æ˜“äºæ‰©å±•å…¶ä»–ä¼ è¾“æ–¹å¼(WebSocket, gRPC)

2. **å®Œæ•´çš„å·¥å…·è°ƒç”¨æµç¨‹**
   - LLM è¿”å› tool_calls
   - è°ƒç”¨ MCP Server æ‰§è¡Œå·¥å…·
   - å°†å·¥å…·ç»“æœè¿”å›ç»™ LLM
   - ç”Ÿæˆæœ€ç»ˆå“åº”

3. **äº‹ä»¶ç›‘å¬å’Œå¹¿æ’­**
   - ç‹¬ç«‹çš„ EventListener æ¨¡å—
   - è‡ªåŠ¨å°† MCP äº‹ä»¶è½¬æ¢ä¸º WebSocket æ¨é€
   - æ”¯æŒå¤šç§äº‹ä»¶ç±»å‹

4. **Mock æ”¯æŒ**
   - Mock MCP Client ç”¨äºå¼€å‘å’Œæµ‹è¯•
   - æ¨¡æ‹Ÿå¸¸è§å·¥å…·çš„å“åº”
   - æ¨¡æ‹Ÿäº‹ä»¶ç”Ÿæˆ

5. **ç®€åŒ–æ¶æ„**
   - Handler ç›´æ¥è°ƒç”¨ MCPClient
   - æ— é¢å¤–æŠ½è±¡å±‚
   - ä»£ç ç®€æ´,æ˜“äºç†è§£

6. **é”™è¯¯å¤„ç†**
   - å·¥å…·è°ƒç”¨å¤±è´¥å¤„ç†
   - LLM åç»­è°ƒç”¨å¤±è´¥å¤„ç†
   - äº‹ä»¶ç›‘å¬é”™è¯¯å¤„ç†

---

## æ–‡ä»¶æ¸…å•

### æ–°å¢æ–‡ä»¶

```
internal/mcp/
  â”œâ”€â”€ client.go          # MCP Client æ¥å£å’Œå·¥å‚
  â”œâ”€â”€ http.go            # HTTP MCP Client å®ç°
  â”œâ”€â”€ mock.go            # Mock MCP Client å®ç°
  â”œâ”€â”€ listener.go        # äº‹ä»¶ç›‘å¬å™¨
  â””â”€â”€ types.go           # MCP ç±»å‹å®šä¹‰

pkg/config/
  â””â”€â”€ config.go          # æ‰©å±• MCPConfig (ä¿®æ”¹)
```

### ä¿®æ”¹æ–‡ä»¶

```
internal/api/handler/
  â””â”€â”€ message.go         # å®Œæˆå·¥å…·è°ƒç”¨æµç¨‹ (ä¿®æ”¹)

internal/cli/
  â””â”€â”€ server.go          # åˆå§‹åŒ– MCP Client (ä¿®æ”¹)

internal/ws/
  â””â”€â”€ hub.go             # äº‹ä»¶å¹¿æ’­ (å¯èƒ½éœ€è°ƒæ•´)
```

---

## ä½¿ç”¨ç¤ºä¾‹

### 1. ä½¿ç”¨ Mock MCP Server

```bash
# é…ç½® Mock æ¨¡å¼
export MCP_SERVER_URL=mock://
export LLM_PROVIDER=mock

# å¯åŠ¨æœåŠ¡å™¨
./bin/dnd-client.exe server start

# å‘é€æ¶ˆæ¯
curl -X POST http://localhost:8080/api/sessions/{session-id}/chat \
  -H "Content-Type: application/json" \
  -d '{
    "content": "æŠ•æ·ä¸€ä¸ª d20",
    "player_id": "player-123"
  }'

# æµç¨‹:
# 1. Mock LLM è¿”å› tool_calls: roll_dice
# 2. Mock MCP æ‰§è¡Œå·¥å…·,è¿”å›ç»“æœ: total=18
# 3. Mock LLM ç”Ÿæˆæœ€ç»ˆå“åº”
# 4. è¿”å›æœ€ç»ˆæ¶ˆæ¯
```

### 2. ä½¿ç”¨çœŸå® MCP Server

```bash
# é…ç½®çœŸå® MCP Server
export MCP_SERVER_URL=http://localhost:9000
export LLM_PROVIDER=openai
export LLM_API_KEY=sk-xxx

# å¯åŠ¨æœåŠ¡å™¨
./bin/dnd-client.exe server start

# è¿æ¥ WebSocket è®¢é˜…äº‹ä»¶
websocat ws://localhost:8080/ws/sessions/{session-id}?key={ws-key}

# å‘é€è®¢é˜…
{"type":"subscribe","data":{"events":["dice_rolled","state_changed"]}}

# å‘é€æ¶ˆæ¯
curl -X POST http://localhost:8080/api/sessions/{session-id}/chat \
  -H "Content-Type: application/json" \
  -d '{
    "content": "æˆ‘è¦æ”»å‡»å“¥å¸ƒæ—",
    "player_id": "player-123"
  }'

# æµç¨‹:
# 1. OpenAI LLM è¿”å› tool_calls: resolve_attack
# 2. MCP Server æ‰§è¡Œå·¥å…·,è¿”å›æ”»å‡»ç»“æœ
# 3. OpenAI LLM æ ¹æ®ç»“æœç”Ÿæˆå“åº”
# 4. WebSocket æ¨é€äº‹ä»¶(å¦‚ combat_updated)
```

---

## æµ‹è¯•è¦†ç›–

- âœ… MCP Client åˆå§‹åŒ–å’Œæ¡æ‰‹
- âœ… å·¥å…·è°ƒç”¨æ‰§è¡Œ(æˆåŠŸåœºæ™¯)
- âœ… å·¥å…·è°ƒç”¨å¤±è´¥å¤„ç†
- âœ… LLM åç»­è°ƒç”¨(å¸¦å·¥å…·ç»“æœ)
- âœ… äº‹ä»¶è®¢é˜…å’Œç›‘å¬
- âœ… äº‹ä»¶è½¬æ¢ä¸º WebSocket æ¨é€
- âœ… Mock MCP Server åŠŸèƒ½
- âœ… ç«¯åˆ°ç«¯æµ‹è¯•(Mock æ¨¡å¼)

---

## æ€§èƒ½æŒ‡æ ‡

| æ“ä½œ           | é¢„æœŸå“åº”æ—¶é—´ | è¯´æ˜                      |
| ------------- | ------ | ----------------------- |
| MCP æ¡æ‰‹        | <100ms | HTTP è¯·æ±‚                 |
| å·¥å…·è°ƒç”¨         | <200ms | HTTP è¯·æ±‚ + å¤„ç†            |
| LLM åç»­è°ƒç”¨     | 1-3s   | åŒ…å«å·¥å…·ç»“æœçš„ LLM è°ƒç”¨        |
| äº‹ä»¶ç›‘å¬å’Œå¹¿æ’­     | <10ms  | å†…å­˜æ“ä½œ                   |

---

## åç»­æ‰©å±•

**ä»»åŠ¡å…«(æŒä¹…åŒ–è§¦å‘å™¨)**:
- å®ç°å¤šç§è§¦å‘å™¨ç­–ç•¥
- é…ç½®åŒ–ç®¡ç†è§¦å‘å™¨

**é•¿æœŸæ‰©å±•**:
- WebSocket MCP Client(åŒå‘å®æ—¶é€šä¿¡)
- å·¥å…·è°ƒç”¨ç»“æœç¼“å­˜
- å¹¶è¡Œå·¥å…·è°ƒç”¨
- å·¥å…·è°ƒç”¨é‡è¯•æœºåˆ¶

---

## æ€»ç»“

ä»»åŠ¡ä¸ƒåœ¨ä»»åŠ¡äº”ã€ä»»åŠ¡å…­çš„åŸºç¡€ä¸Šå®ç°äº† MCP Server é›†æˆ:

1. âœ… **MCP Client åˆå§‹åŒ–å’Œæ¡æ‰‹** - æ¥å£åŒ–è®¾è®¡,æ”¯æŒ HTTP å’Œ Mock
2. âœ… **è°ƒç”¨ MCP Server å·¥å…·** - å®Œæ•´çš„å·¥å…·è°ƒç”¨æµç¨‹
3. âœ… **è®¢é˜… MCP Server äº‹ä»¶** - ç‹¬ç«‹çš„äº‹ä»¶ç›‘å¬å™¨
4. âœ… **äº‹ä»¶è½¬æ¢ä¸º WebSocket æ¨é€** - æ— ç¼é›†æˆä»»åŠ¡äº”çš„ WebSocket
5. âœ… **Mock MCP Server** - ç”¨äºå¼€å‘å’Œæµ‹è¯•
6. âœ… **ç®€åŒ–æ¶æ„** - Handler ç›´æ¥è°ƒç”¨ MCPClient
7. âœ… **å‘åå…¼å®¹** - ä¸ç ´åå·²æœ‰ä»£ç 

ä¸¥æ ¼éµå¾ª `doc/è§„èŒƒ.md`,å¤ç”¨ä»»åŠ¡ä¸€è‡³å…­çš„å®ç°,ä¿æŒç®€åŒ–æ¶æ„é£æ ¼ã€‚

---

**å¼€å‘å®Œæˆæ—¶é—´**: 2025-02-04
**å¼€å‘è€…**: Claude (Anthropic)
**çŠ¶æ€**: âœ… å·²å®Œæˆ
